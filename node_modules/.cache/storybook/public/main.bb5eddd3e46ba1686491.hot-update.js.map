{"version":3,"file":"main.bb5eddd3e46ba1686491.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAHA;;AAgBA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AAAA;;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;ACnCA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAHA;AAWA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAFA;AAHA;AAZA;AAqBA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAHA;AAMA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAFA;AAlCA;AAuCA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5EA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AA8BA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AARA;AACA;AACA;AACA;AAJA;AASA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAhDA;AAAA;AAAA;AAmDA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAAA;;AACA;AAIA;AACA;AAhEA;AAAA;AAAA;AAmEA;AACA;AACA;AArEA;AAAA;AAAA;AAuEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAlFA;AAAA;AAAA;AAqFA;AAEA;AAAA;AAAA;AAEA;AAzFA;AAAA;AAAA;AA4FA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AALA;AAWA;AAzGA;AAAA;AAAA;AA2GA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AACA;AACA;AACA;AAjJA;AAAA;AAAA;AAmJA;;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AA3JA;AAAA;AAAA;AA8JA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAnKA;AAAA;AAAA;AAqKA;AAAA;;AACA;AACA;AACA;AACA;AAHA;AAKA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AArLA;AAAA;AAAA;AAuLA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAnMA;AAAA;AAAA;AAqMA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA7MA;AAAA;AAAA;AA+MA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAnPA;AAAA;AAAA;AAqPA;;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAKA;AADA;AAIA;AACA;AACA;AAlRA;AAAA;AAAA;AAqRA;AACA;AAtRA;AAAA;AAAA;AAyRA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AA/UA;;AAAA;AAAA","sources":["webpack://@pinpoint-fe/scatter-chart/./src/stories/index.stories.ts","webpack://@pinpoint-fe/scatter-chart/./src/stories/ScatterChartStory.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/ScatterChart.ts"],"sourcesContent":["\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import { createScatterChart, createScatterChartResizable } from './ScatterChartStory';\\n\\n// More on default export: https://storybook.js.org/docs/html/writing-stories/introduction#default-export\\nexport default {\\n  title: 'ScatterChart',\\n  // More on argTypes: https://storybook.js.org/docs/html/api/argtypes\\n  argTypes: {\\n    // backgroundColor: { control: 'color' },\\n    // label: { control: 'text' },\\n    // onClick: { action: 'onClick' },\\n    // primary: { control: 'boolean' },\\n    // size: {\\n    //   control: { type: 'select' },\\n    //   options: ['small', 'medium', 'large'],\\n    // },\\n  },\\n};\\n\\n// More on component templates: https://storybook.js.org/docs/html/writing-stories/introduction#using-args\\nconst TemplateDefault = () => createScatterChart();\\nexport const Defatult = TemplateDefault.bind({});\\n\\nconst TemplateResize = () => createScatterChartResizable();\\nexport const Resize = TemplateResize.bind({});\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Defatult\":{\"startLoc\":{\"col\":24,\"line\":20},\"endLoc\":{\"col\":50,\"line\":20},\"startBody\":{\"col\":24,\"line\":20},\"endBody\":{\"col\":50,\"line\":20}},\"Resize\":{\"startLoc\":{\"col\":23,\"line\":23},\"endLoc\":{\"col\":58,\"line\":23},\"startBody\":{\"col\":23,\"line\":23},\"endBody\":{\"col\":58,\"line\":23}}};\n    \nimport { createScatterChart, createScatterChartResizable } from './ScatterChartStory';\n\n// More on default export: https://storybook.js.org/docs/html/writing-stories/introduction#default-export\nexport default {\n  title: 'ScatterChart',\n  // More on argTypes: https://storybook.js.org/docs/html/api/argtypes\n  argTypes: {\n    // backgroundColor: { control: 'color' },\n    // label: { control: 'text' },\n    // onClick: { action: 'onClick' },\n    // primary: { control: 'boolean' },\n    // size: {\n    //   control: { type: 'select' },\n    //   options: ['small', 'medium', 'large'],\n    // },\n  },\n};\n\n// More on component templates: https://storybook.js.org/docs/html/writing-stories/introduction#using-args\nconst TemplateDefault = () => createScatterChart();\nexport const Defatult = TemplateDefault.bind({});;\n\nconst TemplateResize = () => createScatterChartResizable();\nexport const Resize = TemplateResize.bind({});\n\n\nDefatult.parameters = { storySource: { source: \"() => createScatterChart()\" }, ...Defatult.parameters };\nResize.parameters = { storySource: { source: \"() => createScatterChartResizable()\" }, ...Resize.parameters };","import { ScatterChart } from \"../ui\";\n\nconst newScatterChart = (wrapper: HTMLElement) => {\n  return new ScatterChart(wrapper, {\n    axis: {\n      x: {\n        min: 1671684304000,\n        max: 1671687904000,\n        tick: {\n          count: 5,\n          format: (value) => {\n            const date = new Date(value);\n            return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}:${String(date.getSeconds()).padStart(2, '0')}`;\n          }, \n        }\n      },\n      y: {\n        min: 0,\n        max: 10000,\n        tick: {\n          count: 5,\n          format: (value) => value.toLocaleString(),\n        }\n      }\n    },\n    data: [\n      {\n        type: 'success',\n        color: 'green',\n        priority: 11,\n      },\n      {\n        type: 'fail',\n        color: 'red',\n        priority: 1,\n      },\n    ],\n    legend: {\n      formatLabel: (label) => label.toUpperCase(),\n      formatValue: (value) => value.toLocaleString(),\n    },\n  });\n}\n\nexport const createScatterChart = () => {\n  const wrapper = document.createElement('div');\n  setTimeout(() => {\n    newScatterChart(wrapper);\n  }, 500);\n  return wrapper;\n}\n\n\nexport const createScatterChartResizable = () => {\n  const wrapper = document.createElement('div');\n  const btnElement1 = document.createElement('button');\n  btnElement1.innerHTML = 'resize';\n  const btnElement2 = document.createElement('button');\n  btnElement2.innerHTML = 'resize 500 by 500';\n  \n  setTimeout(() => {\n    \n    const SC = newScatterChart(wrapper);\n    wrapper.append(btnElement1);\n    wrapper.append(btnElement2);\n\n    btnElement1.addEventListener('click', () => {\n      SC.resize();\n    });\n\n    btnElement2.addEventListener('click', () => {\n      SC.resize(500, 500);\n    });\n\n  }, 500);\n  return wrapper;\n}","import merge from 'lodash.merge';\n\nimport { AxisOption, DataOption, LegendOption, ScatterDataType } from \"../types\";\nimport { Layer } from \"./Layer\";\nimport { Viewport } from \"./Viewport\";\nimport { drawCircle } from \"../utils/draw\";\nimport { YAxis } from \"./YAxis\";\nimport { XAxis } from \"./XAxis\";\nimport { AXIS_INNER_PADDING, AXIS_TICK_LENGTH, CONTAINER_HEIGHT, CONTAINER_WIDTH, LAYER_DEFAULT_PRIORITY, TEXT_MARGIN_BOTTOM, TEXT_MARGIN_LEFT, TEXT_MARGIN_RIGHT, TEXT_MARGIN_TOP } from \"../constants/ui\";\nimport { GridAxis } from \"./GridAxis\";\nimport { Legend } from \"./Legend\";\nimport { Guide } from \"./Guide\";\nimport { defaultAxisOption, defaultDataOption, defaultLegendOption } from \"../constants/options\";\nimport { isThisWeek } from 'date-fns';\n\nexport interface ScatterChartOption {\n  axis: { x: AxisOption, y: AxisOption };\n  data: DataOption[];\n  legend?: LegendOption;\n}\n\nexport class ScatterChart {\n  private wrapper;\n  private canvasWrapper;\n  private options!: ScatterChartOption;\n  private xAxis!: XAxis;\n  private yAxis!: YAxis;\n  private gridAxis!: GridAxis;\n  private legend!: Legend;\n  private dataColorMap!: { [key: string]: string };\n  private viewport!: Viewport;\n  private guide!: Guide;\n  private layers: { [key: string]: Layer } = {};\n  private datas: {[key: string]: number[]} = {};\n  private xRatio = 1;\n  private yRatio = 1;\n  private coordX = 0;\n  private coordY = 0;\n  private realtimeAxisMinX = 0;\n  private realtimeAxisMaxX = 0;\n  private width = 0;\n  private height = 0;\n  private padding = {\n    top: 15,\n    bottom: 20,\n    left: 0,\n    right: 0,\n  }\n  private t0: number = 0;\n  private reqAnimation = 0;\n\n  constructor(wrapper: HTMLElement, options: ScatterChartOption) {\n    this.wrapper = wrapper;\n    this.canvasWrapper = document.createElement('div');\n    this.canvasWrapper.style.position = 'relative';\n    this.wrapper.append(this.canvasWrapper);\n\n    this.setOptions(options);\n    this.setWidthAndHeight();\n    this.setViewPort();\n    this.setPadding();\n    this.setRatio();\n    this.setAxis();\n    this.setGuide();\n    this.setLayers();\n    this.setLegends();\n\n    this.shoot();\n    this.animate = this.animate.bind(this);\n  }\n\n  private setOptions(options: ScatterChartOption) {\n    this.options = {\n      // TODO deep copy\n      axis: merge(defaultAxisOption, options.axis),\n      data: [...defaultDataOption, ...options.data],\n      legend: merge(defaultLegendOption, options.legend),\n    };\n\n    this.dataColorMap = this.options.data.reduce((prev, curr) => {\n      return {\n        [curr.type]: curr.color,\n        ...prev,\n      }\n    }, {});\n  }\n\n  private setWidthAndHeight() {\n    this.width = this.canvasWrapper.clientWidth || CONTAINER_WIDTH;\n    this.height = this.canvasWrapper.clientHeight || CONTAINER_HEIGHT;\n  }\n\n  private setPadding() {\n    const xformatter = this.options.axis.x.tick?.format;\n    const yformatter = this.options.axis.y.tick?.format;\n    const formattedMaxX = xformatter ? xformatter(this.options.axis.x.max) : this.options.axis.x.max;\n    const formattedMaxY = yformatter ? yformatter(this.options.axis.y.max) : this.options.axis.y.max;\n    const maxXWidth = this.viewport.viewLayer.getTextWidth(formattedMaxX);\n    const maxYWidth = this.viewport.viewLayer.getTextWidth(formattedMaxY);\n\n    this.padding.left = (maxXWidth / 2 > maxYWidth ? maxXWidth / 2 : maxYWidth) + TEXT_MARGIN_LEFT + TEXT_MARGIN_RIGHT + AXIS_TICK_LENGTH;\n    this.padding.right = maxXWidth / 2 + TEXT_MARGIN_RIGHT;\n    this.padding.bottom = this.viewport.viewLayer.getTextHeight(formattedMaxX) + TEXT_MARGIN_TOP + TEXT_MARGIN_BOTTOM + AXIS_TICK_LENGTH;\n  }\n\n  private setViewPort() {\n    this.viewport = new Viewport(\n      this.canvasWrapper,\n      { width: this.width, height: this.height }\n    );\n  }\n\n  private setGuide() {\n    this.guide = new Guide(\n      this.canvasWrapper,\n      { \n        width: this.width, \n        height: this.height, \n        padding: this.padding, \n        axisOption: this.options.axis,\n        ratio: {\n          x: this.xRatio,\n          y: this.yRatio,\n        }\n      }\n    )\n  }\n\n  private setAxis() {\n    const options = this.options;\n\n    this.yAxis = new YAxis({\n      min: options.axis.y.min,\n      max: options.axis.y.max,\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: -2,\n      fixed: true,\n      tickOption: options.axis.y.tick,\n    });\n\n    this.xAxis = new XAxis({\n      min: options.axis.x.min,\n      max: options.axis.x.max,\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: -1,\n      tickOption: options.axis.x.tick,\n    });\n\n    this.gridAxis = new GridAxis({\n      min: options.axis.x.min,\n      max: options.axis.x.max,\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: 9999,\n      xTickCount: options.axis.x.tick?.count,\n      yTickCount: options.axis.y.tick?.count,\n    })\n\n    this.viewport.addLayer(this.yAxis);\n    this.viewport.addLayer(this.xAxis);\n    this.viewport.addLayer(this.gridAxis);\n  }\n\n  private setLayers() {\n    const width = this.viewport.styleWidth;\n    const height = this.viewport.styleHeight;\n    const dataOptions = this.options.data;\n\n    dataOptions.forEach(({ type, priority = LAYER_DEFAULT_PRIORITY }) => {\n      this.setLayer(type, width, height, priority);\n    })\n  }\n\n  private setLayer(legend: string, width: number, height: number, priority: number) {\n    const layer = new Layer({ width, height });\n    layer.id = legend;\n    layer.priority = priority;\n    this.layers[legend] = layer;\n    this.viewport.addLayer(layer);\n  }\n\n  private setLegends() {\n    this.legend = new Legend(this.wrapper, { \n      types: Object.keys(this.layers), \n      dataColorMap: this.dataColorMap,\n      legendOptions: this.options?.legend!\n    });\n    this.legend.addEvents(({ type, checked }) => {\n      if (type) {\n        if (checked) {\n          this.viewport.showLayer(type);\n        } else {\n          this.viewport.hideLayer(type);\n        }\n      }\n      this.shoot();\n    }).render();\n  }\n\n  private setRatio() {\n    const axis = this.options?.axis;\n    const padding = this.padding;\n    const width = this.viewport.canvas.width / this.viewport.viewLayer.dpr;\n    const height = this.viewport.canvas.height / this.viewport.viewLayer.dpr;\n    const minX = axis.x.min;\n    const maxX = axis.x.max;\n    const minY = axis.y.min;\n    const maxY = axis.y.max;\n\n    this.xRatio = (width - padding.left - padding.right - AXIS_INNER_PADDING * 2) / (maxX - minX);\n    this.yRatio = (height - padding.bottom - padding.top - AXIS_INNER_PADDING * 2) / (maxY - minY);\n  }\n\n  private shoot() {\n    this.viewport.clear();\n    this.viewport.render(this.coordX, this.coordY);\n    \n    Object.keys(this.datas).forEach(key => {\n      // this.datas[key].sort((a,b) => a - b);\n      this.legend.setLegendCount(key, this.datas[key].length);\n    })\n  }\n\n  private animate(duration: number, now: number) {\n    this.shoot();\n    if (!this.t0) this.t0 = now;\n    const dt = now - this.t0;\n    const pixcelPerFrame = (this.viewport.styleWidth - this.padding.left - this.padding.right - AXIS_INNER_PADDING * 2) / duration * dt;\n    const pixcelPerSecond = pixcelPerFrame * 60;\n\n    this.t0 = now;\n    this.coordX = this.coordX - pixcelPerFrame;\n\n    // 특정 주기마다 시행\n    if (Math.abs(Math.floor(this.coordX)) % (Math.floor(pixcelPerSecond / 5)) === 0) {\n      const x = Math.abs(this.coordX) / this.xRatio;\n      Object.keys(this.datas).forEach(key => {\n        this.datas[key] = this.datas[key].filter(d => d > x);\n      })\n\n      this.guide.updateXAxis({ min: x + this.xAxis.min});\n    }\n\n    if (this.coordX > -(this.viewport.styleWidth - this.padding.left - this.padding.right - AXIS_INNER_PADDING * 2)) {\n      this.reqAnimation = requestAnimationFrame((t) => this.animate(duration, t))\n    } else {\n      // swap\n      const nextAxisMinX = this.realtimeAxisMinX + (this.realtimeAxisMaxX - this.realtimeAxisMinX) / 2;\n      const nextAxisMaxX = this.realtimeAxisMaxX + (this.realtimeAxisMaxX - this.realtimeAxisMinX) / 2;\n      this.realtimeAxisMinX = nextAxisMinX;\n      this.realtimeAxisMaxX = nextAxisMaxX;\n      this.coordX = 0;\n\n      this.xAxis\n        .setMinMax(this.realtimeAxisMinX, this.realtimeAxisMaxX)\n        .render();\n      Object.values(this.layers).filter(layer => !layer.isFixed).forEach(layer =>  layer.swapCanvasImage());\n      this.reqAnimation = requestAnimationFrame((t) => this.animate(duration, t))\n    }\n  }\n\n  public render(data: ScatterDataType[], { append = false } = {}) {\n    this.setRatio();\n    const { styleWidth, styleHeight } = this.viewport;\n    const padding = this.padding;\n\n    !append && this.viewport.clear();\n    data.forEach(({ x, y, type, hidden }, i) => {\n      const legend = type ? type : 'unknown';\n      \n      if (!this.layers[legend]) {\n        this.setLayer(legend, styleWidth, styleHeight, LAYER_DEFAULT_PRIORITY);\n      }\n\n      if (this.datas[legend]) {\n        this.datas[legend].push(x);\n      } else {\n        this.datas[legend] = [x];\n      }\n\n      !hidden && drawCircle(\n        this.layers[legend].context,\n        this.xRatio * x + padding.left + AXIS_INNER_PADDING,\n        this.viewport.canvas.height / this.viewport.viewLayer.dpr - this.yRatio * y - padding.bottom - AXIS_INNER_PADDING,\n        {\n          fillColor: this.dataColorMap[legend],\n        }\n      );\n    });\n    this.shoot();\n  }\n\n  public on(evetntType: string, callback: (data: any) => void) {\n    this.guide.on(evetntType, callback);\n  }\n\n  public resize(width?: number, height?: number) {\n    const w = width || this.canvasWrapper.clientWidth;\n    const h = height || this.canvasWrapper.clientHeight;\n\n    this.viewport.setSize(w, h);\n    this.setRatio();\n    this.xAxis.setSize(w, h);\n    this.yAxis.setSize(w, h);\n    this.gridAxis.setSize(w, h);\n    this.guide.setSizeAndRatio(w, h, { x: this.xRatio, y: this.yRatio });\n    Object.values(this.layers).forEach(layer => layer.setSize(w, h));\n    this.legend.setSize(w);\n    this.shoot();\n  }\n\n  // public startRealtime(duration: number) {\n  //   if (this.reqAnimation) return;\n  //   const axisOptions = this.options.axis;\n  //   this.xAxis\n  //     .setTickCount(axisOptions.x.tick?.count! * 2 - 1)\n  //     .setSize(this.width * 2 - this.padding.left - AXIS_INNER_PADDING * 2 - this.padding.right, this.height)\n  //     .setMinMax(axisOptions.x.min, axisOptions.x.max * 2 - axisOptions.x.min)\n  //     .render();\n  //   this.realtimeAxisMinX = axisOptions.x.min;\n  //   this.realtimeAxisMaxX = axisOptions.x.max * 2 - axisOptions.x.min;\n\n  //   this.gridAxis\n  //     .setXTickCount(axisOptions.x.tick?.count! * 2 - 1)\n  //     .setSize(this.width * 2 - this.padding.left - AXIS_INNER_PADDING * 2 - this.padding.right, this.height)\n  //     .render();\n  //   this.animate(duration, this.t0);\n  // }\n\n  // public stopRealtime() {\n  //   cancelAnimationFrame(this.reqAnimation);\n  //   const axisOptions = this.options.axis;\n  //   this.reqAnimation = 0;\n  //   this.coordX = 0;\n  //   this.t0 = 0;\n\n  //   this.xAxis\n  //     .setTickCount(axisOptions.x.tick?.count!)\n  //     .setSize(this.width, this.height)\n  //     .setMinMax(axisOptions.x.min, axisOptions.x.max)\n  //     .render();\n  //   this.realtimeAxisMinX = axisOptions.x.min;\n  //   this.realtimeAxisMaxX = axisOptions.x.max;\n\n  //   this.guide.updateXAxis({ min: axisOptions.x.min });\n\n  //   this.gridAxis\n  //     .setXTickCount(axisOptions.x.tick?.count!)\n  //     .setSize(this.width, this.height)\n  //     .render();\n  //   this.shoot();\n  // }\n}\n"],"names":[],"sourceRoot":""}