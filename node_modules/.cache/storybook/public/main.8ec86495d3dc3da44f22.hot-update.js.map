{"version":3,"file":"main.8ec86495d3dc3da44f22.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA;AAEA;AAAA;;AAAA;;AACA;AAEA;;AAAA;;AAAA;;AAAA;;AACA;;AACA;;AAFA;AAGA;;AANA;AAAA;AAAA;AASA;;AACA;AACA;AACA;AAZA;AAAA;AAAA;AAcA;;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;AACA;AACA;AAtCA;;AAAA;AAAA","sources":["webpack://@pinpoint-fe/scatter-chart/./src/ui/YAxis.ts"],"sourcesContent":["import { AXIS_INNER_PADDING, AXIS_TICK_LENGTH, TEXT_MARGIN_LEFT, TEXT_MARGIN_RIGHT } from \"../constants/ui\";\nimport { drawLine, drawRect, drawText } from \"../utils/draw\";\nimport { Axis, AxisProps } from \"./Axis\";\n\nexport interface YAxisProps extends AxisProps {};\n\nexport class YAxis extends Axis {\n  constructor({\n    ...props\n  }: YAxisProps = {}) {\n    super(props);\n    this.render();\n  }\n\n  public setSize(width: number, height: number){\n    super.setSize(width, height);\n    this.render();\n    return this;\n  }\n\n  public render() {\n    const { count, format } = this.tickOption;\n    const padding = this.padding;\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n    \n    const startX = padding.left;\n    const startY = padding.top + AXIS_INNER_PADDING;\n    const endY = height - padding.bottom - AXIS_INNER_PADDING;\n    const hGap = (endY - startY) / (count - 1);\n    const yTickGap = (this.max - this.min) / (count - 1);\n\n\n    drawRect(this.context, 0, 0, padding.left, endY + AXIS_INNER_PADDING + AXIS_TICK_LENGTH);\n    drawRect(this.context, width - padding.right, 0, width, endY + AXIS_INNER_PADDING + AXIS_TICK_LENGTH);\n    drawRect(this.context, 0, 0, width, padding.top);\n    \n    [...Array(count)].forEach((_, i) => {\n      const y = hGap * i + startY;\n      const label = format(yTickGap * (count - 1 - i))\n      drawLine(this.context, startX - AXIS_TICK_LENGTH, y, startX, y);\n      drawText(this.context, `${label}`, startX - TEXT_MARGIN_RIGHT - AXIS_TICK_LENGTH, y + 3, { textAlign: 'end' });\n    })\n    drawLine(this.context, startX, startY - AXIS_INNER_PADDING, startX, endY + AXIS_INNER_PADDING);\n  }\n}"],"names":[],"sourceRoot":""}