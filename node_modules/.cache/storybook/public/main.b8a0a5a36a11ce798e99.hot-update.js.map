{"version":3,"file":"main.b8a0a5a36a11ce798e99.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAEA;AACA;AAkBA;AAAA;;AAAA;;AAWA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;;AACA;;AAZA;AAaA;;AA1BA;AAAA;AAAA;AA6BA;AACA;AACA;AAEA;AAMA;AAvCA;AAAA;AAAA;AAyCA;;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAGA;AACA;AAFA;AAKA;AACA;AAEA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAAA;;AACA;;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;;AACA;AACA;AAEA;AACA;AAAA;;AACA;AAAA;;AACA;AACA;AACA;AAFA;AAIA;;AACA;AACA;AACA;AA3GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgHA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAGA;AACA;;AAEA;AACA;;AAGA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AAtIA;AAAA;AAAA;AAyIA;;AACA;AACA;AACA;AACA;AA7IA;AAAA;AAAA;AAgJA;AAAA;AAAA;AACA;AAjJA;AAAA;AAAA;AAoJA;AACA;AArJA;;AAAA;AAAA","sources":["webpack://@pinpoint-fe/scatter-chart/./src/ui/Guide.ts"],"sourcesContent":["import { AXIS_INNER_PADDING, AXIS_TICK_LENGTH, TEXT_MARGIN_BOTTOM, TEXT_MARGIN_LEFT, TEXT_MARGIN_RIGHT, TEXT_MARGIN_TOP } from \"../constants/ui\";\nimport { AxisOption, FormatType, LegendOption } from \"../types\";\nimport { drawLine, drawRect, drawText } from \"../utils/draw\";\nimport { Layer } from \"./Layer\";\n\nexport interface GuideOptions {\n  width: number;\n  height: number;\n  padding: {\n    top: number;\n    right: number;\n    bottom: number;\n    left: number;\n  };\n  ratio: {\n    x: number;\n    y: number;\n  };\n  axisOption: { x: AxisOption, y: AxisOption };\n}\n\nexport class Guide extends Layer {\n  private wrapper;\n  private padding;\n  private ratio;\n  private axis;\n  private isMouseDown = false;\n  private isDragging = false;\n  private dragStartX = 0;\n  private dragStartY = 0;\n  private eventHandlers: {[key: string]: Function} = {};\n\n  constructor(wrapper: HTMLElement, {\n    width, height, padding, ratio, axisOption,\n  }: GuideOptions) {\n    super({ width, height });\n    this.canvas.style.position = 'absolute';\n    this.canvas.style.zIndex = '999';\n    this.canvas.style.top = '0px';\n    this.canvas.style.left = '0px';\n    this.canvas.style.background = 'transparent';\n    this.padding = padding;\n    this.ratio = ratio;\n    this.axis = axisOption;\n    this.wrapper = wrapper;\n    this.wrapper.append(this.canvas);\n    this.addEventListener();\n  }\n\n  private isMouseInValidArea(x: number, y: number) {\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n    const padding = this.padding\n\n    return (\n      x >= padding.left + AXIS_INNER_PADDING &&\n      x <= width - padding.right - AXIS_INNER_PADDING && \n      y >= padding.top + AXIS_INNER_PADDING && \n      y <= height - padding.bottom - AXIS_INNER_PADDING\n    )\n  }\n\n  private addEventListener() {\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n\n    this.canvas.addEventListener('mousedown', ({ offsetX, offsetY }) => {\n      this.isMouseDown = true;\n      this.dragStartX = offsetX;\n      this.dragStartY = offsetY;\n    });\n\n    this.canvas.addEventListener('mousemove', ({ offsetX, offsetY }) => {\n      this.context.clearRect(0, 0, width, height);\n      const x = offsetX;\n      const y = offsetY;\n      if (this.isMouseInValidArea(x, y)) {\n        // vertical line\n        // drawLine(this.context, x , 0, x, height - padding.bottom + AXIS_INNER_PADDING)\n        // horizontal line\n        // drawLine(this.context, padding.left, y, width, y)\n\n        this.drawGuideText(x,y);\n      }\n      if (this.isMouseDown) {\n        this.isDragging = true;\n        drawRect(this.context, \n          this.dragStartX, this.dragStartY, offsetX - this.dragStartX, offsetY - this.dragStartY,\n          {\n            color: 'rgba(225,225,225,0.5)',\n            strokeColor: 'blue',\n          }\n        )\n      }\n    });\n\n    this.canvas.addEventListener('mouseout', event => {\n      this.isMouseDown = false;\n      this.isDragging = false;\n      this.context.clearRect(0, 0, width, height);\n    });\n\n    this.canvas.addEventListener('mouseup', event => {\n      const { offsetX, offsetY } = event;\n      this.context.clearRect(0, 0, width, height);\n      \n      if (this.isDragging) {\n        this.isMouseInValidArea(offsetX, offsetY) && this.drawGuideText(offsetX, offsetY)\n        this.eventHandlers['dragEnd']?.({ \n          x1: this.dragStartX / this.ratio.x + this.axis.x.min,\n          y1: this.axis.y.max - (this.dragStartY - this.padding.top - AXIS_INNER_PADDING) / this.ratio.y,\n          x2: this.axis.y.max - (offsetX - this.padding.top - AXIS_INNER_PADDING) / this.ratio.x + this.axis.x.min,\n          y2: this.axis.y.max - (offsetY - this.padding.top - AXIS_INNER_PADDING) / this.ratio.y,\n        });\n      }\n      this.isMouseDown = false;\n    });\n\n    this.canvas.addEventListener('click', event => {\n      const { offsetX, offsetY } = event;\n      if (!this.isDragging) {\n        this.eventHandlers['click']?.({ \n          x: offsetX / this.ratio.x + this.axis.x.min,\n          y: this.axis.y.max - (offsetY - this.padding.top - AXIS_INNER_PADDING) / this.ratio.y,\n        })\n      }\n      this.isDragging = false;\n    })\n  }\n\n  private removeEventListener() {\n  }\n\n  private drawGuideText(x: number, y: number) {\n    const { padding, context, canvas, ratio, axis } = this;\n    const height = canvas.height / this.dpr;\n    const xText = `${axis.x.tick?.format!((x - padding.left - AXIS_INNER_PADDING) / ratio.x + axis.x.min)}`;\n    const yText = `${axis.y.tick?.format!(Math.floor(Math.abs((height - padding.bottom - AXIS_INNER_PADDING - y) / ratio.y)))}`;\n    \n    // x\n    const xTextWidth = this.getTextWidth(xText) + TEXT_MARGIN_LEFT + TEXT_MARGIN_RIGHT;\n    const xTextHeight = this.getTextHeight(xText) + TEXT_MARGIN_TOP + TEXT_MARGIN_BOTTOM;\n    // y\n    const yTextWidth = this.getTextWidth(yText) + TEXT_MARGIN_LEFT + TEXT_MARGIN_RIGHT;\n    const yTextHeight = this.getTextHeight(yText) + TEXT_MARGIN_TOP + TEXT_MARGIN_BOTTOM;\n\n    // x\n    drawRect(context, x - xTextWidth / 2, height - padding.bottom + AXIS_TICK_LENGTH, xTextWidth, xTextHeight, { color: 'black' });\n    drawLine(context, padding.left - AXIS_TICK_LENGTH, y, padding.left, y);\n    drawText(context, xText, x, height - TEXT_MARGIN_BOTTOM, { color: 'white', textAlign: 'center', textBaseline: 'bottom' });\n    // y\n    drawRect(context, padding.left - AXIS_TICK_LENGTH - yTextWidth, y - yTextHeight / 2, yTextWidth, yTextHeight, { color: 'black' });\n    drawLine(context, x, height - padding.bottom, x, height - padding.bottom + AXIS_TICK_LENGTH);\n    drawText(context, yText, padding.left - AXIS_TICK_LENGTH - TEXT_MARGIN_RIGHT, y + 3, { color: 'white', textAlign: 'end' });\n    \n  }\n\n  public setSize(width: number, height: number, ratio: { x: number, y: number }){\n    super.setSize(width, height);\n    this.removeEventListener();\n    this.addEventListener();\n    return this;\n  }\n\n  public updateXAxis(x: Partial<AxisOption>) {\n    this.axis = {...this.axis, ...{ x: {...this.axis.x, ...x}}}\n  }\n\n  public on(evetntType: string, callback: (data: any) => void) {\n    this.eventHandlers[evetntType] = callback;\n  }\n}"],"names":[],"sourceRoot":""}