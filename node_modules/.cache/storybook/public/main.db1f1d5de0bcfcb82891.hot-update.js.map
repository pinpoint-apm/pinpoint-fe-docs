{"version":3,"file":"main.db1f1d5de0bcfcb82891.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AA0BA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AA5CA;AAAA;AAAA;AA+CA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAAA;;AACA;AAIA;AACA;AA5DA;AAAA;AAAA;AA+DA;AACA;AACA;AAjEA;AAAA;AAAA;AAmEA;AAAA;;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AA9EA;AAAA;AAAA;AAiFA;AAEA;AAAA;AAAA;AAEA;AArFA;AAAA;AAAA;AAwFA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AALA;AAWA;AArGA;AAAA;AAAA;AAuGA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AACA;AACA;AAvIA;AAAA;AAAA;AAyIA;;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAjJA;AAAA;AAAA;AAoJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAzJA;AAAA;AAAA;AA2JA;AAAA;;AACA;AACA;AACA;AACA;AAHA;AAKA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AA3KA;AAAA;AAAA;AA6KA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAzLA;AAAA;AAAA;AA2LA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAnMA;AAAA;AAAA;AAqMA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAzOA;AAAA;AAAA;AA2OA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAKA;AADA;AAIA;AACA;AACA;AACA;AAlRA;AAAA;AAAA;AAqRA;AACA;AAtRA;AAAA;AAAA;AAyRA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAHA;AAKA;AAAA;AAAA;AACA;AACA;AACA;AAzSA;AAAA;AAAA;AA+SA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAFA;AAIA;AAEA;AACA;AACA;AAHA;AAMA;AAEA;AACA;AACA;AAHA;AAMA;AACA;AAAA;AAEA;AACA;AAxUA;AAAA;AAAA;AA2UA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AAEA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAlZA;;AAAA;AAAA","sources":["webpack://@pinpoint-fe/scatter-chart/./src/ui/ScatterChart.ts"],"sourcesContent":["import merge from 'lodash.merge';\nimport clonedeep from 'lodash.clonedeep';\n\nimport { AxisOption, DataOption, LegendOption, Padding, ScatterDataType } from \"../types\";\nimport { Layer } from \"./Layer\";\nimport { Viewport } from \"./Viewport\";\nimport { drawCircle, drawRect, drawText } from \"../utils/draw\";\nimport { YAxis } from \"./YAxis\";\nimport { XAxis } from \"./XAxis\";\nimport { AXIS_INNER_PADDING, AXIS_TICK_LENGTH, CONTAINER_HEIGHT, CONTAINER_PADDING, CONTAINER_WIDTH, LAYER_DEFAULT_PRIORITY, TEXT_MARGIN_BOTTOM, TEXT_MARGIN_LEFT, TEXT_MARGIN_RIGHT, TEXT_MARGIN_TOP } from \"../constants/ui\";\nimport { GridAxis } from \"./GridAxis\";\nimport { Legend } from \"./Legend\";\nimport { Guide } from \"./Guide\";\nimport { defaultAxisOption, defaultDataOption, defaultLegendOption } from \"../constants/options\";\nimport { getLongestTextWidth, getTickTexts } from '../utils/helper';\nimport html2canvas from 'html2canvas';\n\nexport interface ScatterChartOption {\n  axis: { x: AxisOption, y: AxisOption };\n  data: DataOption[];\n  legend?: LegendOption;\n}\n\nexport class ScatterChart {\n  private wrapper;\n  private canvasWrapper;\n  private options!: ScatterChartOption;\n  private xAxis!: XAxis;\n  private yAxis!: YAxis;\n  private gridAxis!: GridAxis;\n  private legend!: Legend;\n  private dataColorMap!: { [key: string]: string };\n  private viewport!: Viewport;\n  private guide!: Guide;\n  private dataLayers: { [key: string]: Layer } = {};\n  private data: ScatterDataType[] = [];\n  private datas: {[key: string]: number[]} = {};\n  private xRatio = 1;\n  private yRatio = 1;\n  private coordX = 0;\n  private coordY = 0;\n  private realtimeAxisMinX = 0;\n  private realtimeAxisMaxX = 0;\n  private width = 0;\n  private height = 0;\n  private padding = CONTAINER_PADDING;\n  private t0: number = 0;\n  private reqAnimation = 0;\n\n  constructor(wrapper: HTMLElement, options: ScatterChartOption) {\n    this.wrapper = wrapper;\n    this.canvasWrapper = document.createElement('div');\n    this.canvasWrapper.style.position = 'relative';\n    this.wrapper.append(this.canvasWrapper);\n\n    this.setOptions(options);\n    this.setWidthAndHeight();\n    this.setViewPort();\n    this.setPadding();\n    this.setRatio();\n    this.setAxis();\n    this.setGuide();\n    this.setLayers();\n    this.setLegends();\n\n    this.shoot();\n    this.animate = this.animate.bind(this);\n  }\n\n  private setOptions(options: ScatterChartOption) {\n    this.options = {\n      // TODO deep copy\n      axis: merge(defaultAxisOption, options.axis),\n      data: [...defaultDataOption, ...options.data],\n      legend: merge(defaultLegendOption, options.legend),\n    };\n\n    this.dataColorMap = this.options.data.reduce((prev, curr) => {\n      return {\n        [curr.type]: curr.color,\n        ...prev,\n      }\n    }, {});\n  }\n\n  private setWidthAndHeight() {\n    this.width = this.canvasWrapper.clientWidth || CONTAINER_WIDTH;\n    this.height = this.canvasWrapper.clientHeight || CONTAINER_HEIGHT;\n  }\n\n  private setPadding() {\n    const xformatter = this.options.axis.x.tick?.format;\n    const xTicks = getTickTexts(this.options.axis.x);\n    const yTicks = getTickTexts(this.options.axis.y);\n    const maxXTickTextWidth = getLongestTextWidth(xTicks, (t) => this.viewport.viewLayer.getTextWidth(t));\n    const maxYTickTextWidth = getLongestTextWidth(yTicks, (t) => this.viewport.viewLayer.getTextWidth(t));\n    const formattedXSample = xformatter ? xformatter(this.options.axis.x.max) : this.options.axis.x.max;\n\n    this.padding.left = (maxXTickTextWidth / 2 > maxYTickTextWidth ? maxXTickTextWidth / 2 : maxYTickTextWidth) + TEXT_MARGIN_LEFT + TEXT_MARGIN_RIGHT + AXIS_TICK_LENGTH;\n    this.padding.right = maxXTickTextWidth / 2 + TEXT_MARGIN_RIGHT;\n    this.padding.bottom = this.viewport.viewLayer.getTextHeight(formattedXSample) + TEXT_MARGIN_TOP + TEXT_MARGIN_BOTTOM + AXIS_TICK_LENGTH;\n  }\n\n  private setViewPort() {\n    this.viewport = new Viewport(\n      this.canvasWrapper,\n      { width: this.width, height: this.height }\n    );\n  }\n\n  private setGuide() {\n    this.guide = new Guide(\n      this.canvasWrapper,\n      { \n        width: this.width, \n        height: this.height, \n        padding: this.padding, \n        axisOption: this.options.axis,\n        ratio: {\n          x: this.xRatio,\n          y: this.yRatio,\n        }\n      }\n    )\n  }\n\n  private setAxis() {\n    const options = this.options;\n\n    this.yAxis = new YAxis({\n      axisOption: options.axis.y,\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: -2,\n      fixed: true,\n    });\n\n    this.xAxis = new XAxis({\n      axisOption: options.axis.x,\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: -1,\n    });\n\n    this.gridAxis = new GridAxis({\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: 9999,\n      xTickCount: options.axis.x.tick?.count,\n      yTickCount: options.axis.y.tick?.count,\n    })\n\n    this.viewport.addLayer(this.yAxis);\n    this.viewport.addLayer(this.xAxis);\n    this.viewport.addLayer(this.gridAxis);\n  }\n\n  private setLayers() {\n    const width = this.viewport.styleWidth;\n    const height = this.viewport.styleHeight;\n    const dataOptions = this.options.data;\n\n    dataOptions.forEach(({ type, priority = LAYER_DEFAULT_PRIORITY }) => {\n      this.setLayer(type, width, height, priority);\n    })\n  }\n\n  private setLayer(legend: string, width: number, height: number, priority: number) {\n    const layer = new Layer({ width, height });\n    layer.id = legend;\n    layer.priority = priority;\n    this.dataLayers[legend] = layer;\n    this.viewport.addLayer(layer);\n  }\n\n  private setLegends() {\n    this.legend = new Legend(this.wrapper, { \n      types: Object.keys(this.dataLayers), \n      dataColorMap: this.dataColorMap,\n      legendOptions: this.options?.legend!\n    });\n    this.legend.addEvents(({ type, checked }) => {\n      if (type) {\n        if (checked) {\n          this.viewport.showLayer(type);\n        } else {\n          this.viewport.hideLayer(type);\n        }\n      }\n      this.shoot();\n    }).render();\n  }\n\n  private setRatio() {\n    const axis = this.options?.axis;\n    const padding = this.padding;\n    const width = this.viewport.canvas.width / this.viewport.viewLayer.dpr;\n    const height = this.viewport.canvas.height / this.viewport.viewLayer.dpr;\n    const minX = axis.x.min;\n    const maxX = axis.x.max;\n    const minY = axis.y.min;\n    const maxY = axis.y.max;\n\n    this.xRatio = (width - padding.left - padding.right - AXIS_INNER_PADDING * 2) / (maxX - minX);\n    this.yRatio = (height - padding.bottom - padding.top - AXIS_INNER_PADDING * 2) / (maxY - minY);\n  }\n\n  private shoot() {\n    this.viewport.clear();\n    drawRect(this.viewport.context, 0, 0, this.width, this.height);\n    this.viewport.render(this.coordX, this.coordY);\n    \n    Object.keys(this.datas).forEach(key => {\n      this.legend.setLegendCount(key, this.datas[key].length);\n    })\n  }\n\n  private animate(duration: number, now: number) {\n    this.shoot();\n    if (!this.t0) this.t0 = now;\n    const dt = now - this.t0;\n    const pixcelPerFrame = (this.viewport.styleWidth - this.padding.left - this.padding.right - AXIS_INNER_PADDING * 2) / duration * dt;\n    const pixcelPerSecond = pixcelPerFrame * 60;\n\n    this.t0 = now;\n    this.coordX = this.coordX - pixcelPerFrame;\n\n    // 특정 주기마다 시행\n    if (Math.abs(Math.floor(this.coordX)) % (Math.floor(pixcelPerSecond / 5)) === 0) {\n      const x = Math.abs(this.coordX) / this.xRatio;\n      Object.keys(this.datas).forEach(key => {\n        this.datas[key] = this.datas[key].filter(d => d > x);\n      })\n\n      this.guide.updateXAxis({ min: x + this.xAxis.min});\n    }\n\n    if (this.coordX > -(this.viewport.styleWidth - this.padding.left - this.padding.right - AXIS_INNER_PADDING * 2)) {\n      this.reqAnimation = requestAnimationFrame((t) => this.animate(duration, t))\n    } else {\n      // swap\n      const nextAxisMinX = this.realtimeAxisMinX + (this.realtimeAxisMaxX - this.realtimeAxisMinX) / 2;\n      const nextAxisMaxX = this.realtimeAxisMaxX + (this.realtimeAxisMaxX - this.realtimeAxisMinX) / 2;\n      this.realtimeAxisMinX = nextAxisMinX;\n      this.realtimeAxisMaxX = nextAxisMaxX;\n      this.coordX = 0;\n\n      this.xAxis\n        .setMinMax(this.realtimeAxisMinX, this.realtimeAxisMaxX)\n        .render();\n      Object.values(this.dataLayers).filter(layer => !layer.isFixed).forEach(layer =>  layer.swapCanvasImage());\n      this.reqAnimation = requestAnimationFrame((t) => this.animate(duration, t))\n    }\n  }\n\n  public render(data: ScatterDataType[], { append = false } = {}) {\n    const { styleWidth, styleHeight } = this.viewport;\n    const { x: xAxisOptoin, y: yAxisOption } = this.options.axis\n    const padding = this.padding;\n\n    if (append) {\n      this.data = [...this.data, ...data];\n    } else {\n      this.data = data;\n      this.datas = {};\n      Object.values(this.dataLayers).forEach(layer => layer.clear());\n    }\n\n    data.forEach(({ x, y, type, hidden }) => {\n      const legend = type ? type : 'unknown';\n\n      // if (xAxisOptoin.min <= x && xAxisOptoin.max >= x && yAxisOption.min <= y && yAxisOption.max >= y) {\n      if (true) {\n        if (!this.dataLayers[legend]) {\n          this.setLayer(legend, styleWidth, styleHeight, LAYER_DEFAULT_PRIORITY);\n        }\n        \n        if (this.datas[legend]) {\n          this.datas[legend].push(x);\n        } else {\n          this.datas[legend] = [x];\n        }\n  \n        !hidden && drawCircle(\n          this.dataLayers[legend].context,\n          this.xRatio * (x - this.xAxis.min) + padding.left + AXIS_INNER_PADDING,\n          this.viewport.canvas.height / this.viewport.viewLayer.dpr - this.yRatio * y - padding.bottom - AXIS_INNER_PADDING,\n          {\n            fillColor: this.dataColorMap[legend],\n          }\n        );\n      }\n    });\n    this.shoot();\n  }\n\n  public on(evetntType: string, callback: (data: any) => void) {\n    this.guide.on(evetntType, callback);\n  }\n\n  public resize(width?: number, height?: number) {\n    const w = width || this.canvasWrapper.clientWidth;\n    const h = height || this.canvasWrapper.clientHeight;\n\n    this.viewport.setSize(w, h);\n    this.setRatio();\n    this.xAxis.setSize(w, h);\n    this.yAxis.setSize(w, h);\n    this.gridAxis.setSize(w, h);\n    this.guide.setOptions({\n      width: w,\n      height: h,\n      ratio: { x: this.xRatio, y: this.yRatio }\n    });\n    Object.values(this.dataLayers).forEach(layer => layer.setSize(w, h));\n    this.legend.setSize(w);\n    this.render(this.data);\n  }\n\n  public setAxisOption(axisOption: {\n    x?: Pick<AxisOption, 'min' | 'max'>,\n    y?: Pick<AxisOption, 'min' | 'max'>,\n  }) {\n    this.setOptions(merge(this.options, { axis: axisOption }));\n    this.setPadding();\n    this.setRatio();\n    this.guide.setOptions({\n      padding: this.padding,\n      ratio: {x: this.xRatio, y: this.yRatio},\n    });\n    this.xAxis\n      .setOptions({\n        min: this.options.axis.x.min,\n        max: this.options.axis.x.max,\n        padding: this.padding,\n      })\n      .render();\n    this.yAxis\n      .setOptions({\n        min: this.options.axis.y.min,\n        max: this.options.axis.y.max,\n        padding: this.padding,\n      })\n      .render();\n    this.gridAxis\n      .setOptions({ padding: this.padding })\n      .render();\n    this.render(this.data);\n  }\n\n  public toBase64Image() {\n    // this.viewport.setSize(CONTAINER_WIDTH, CONTAINER_HEIGHT).render(0,0);\n    const layer = new Layer({ width: this.width , height: this.height});\n    // const clonedViewPort = clonedeep(this.viewport)\n    // console.log(clonedViewPort === this.viewport);\n    // console.log(clonedViewPort.viewLayer === this.viewport.viewLayer);\n    // clonedViewPort.setSize(CONTAINER_WIDTH, CONTAINER_HEIGHT);\n    // // [...Array.from(clonedLegend.getElementsByTagName('input'))].forEach((node) => {\n    // //   console.log(node)\n    // //   clonedLegend.removeChild(node);\n    // // })\n\n    // layer.setSize(this.width, this.height);\n    // // drawRect(layer.context, 0, 0, this.width, this.height, { color: 'white' });\n    layer.context.putImageData(this.viewport.context.getImageData(0, 0, this.viewport.canvas.width, this.viewport.canvas.height), 0, 0);\n\n    html2canvas(document.querySelector(\"#root\")).then(canvas => {\n      document.body.appendChild(canvas)\n    });\n\n\n    const downloadElement = document.createElement('a');\n    const image = layer.canvas\n      .toDataURL(\"image/png\")\n      .replace(\"image/png\", \"image/octet-stream\");\n    downloadElement.setAttribute(\"href\", image);\n    downloadElement.setAttribute('download', `${1}.png`);\n    this.wrapper.appendChild(downloadElement);\n    downloadElement.click();\n    this.wrapper.removeChild(downloadElement);\n  }\n\n  // public startRealtime(duration: number) {\n  //   if (this.reqAnimation) return;\n  //   const axisOptions = this.options.axis;\n  //   this.xAxis\n  //     .setTickCount(axisOptions.x.tick?.count! * 2 - 1)\n  //     .setSize(this.width * 2 - this.padding.left - AXIS_INNER_PADDING * 2 - this.padding.right, this.height)\n  //     .setMinMax(axisOptions.x.min, axisOptions.x.max * 2 - axisOptions.x.min)\n  //     .render();\n  //   this.realtimeAxisMinX = axisOptions.x.min;\n  //   this.realtimeAxisMaxX = axisOptions.x.max * 2 - axisOptions.x.min;\n\n  //   this.gridAxis\n  //     .setXTickCount(axisOptions.x.tick?.count! * 2 - 1)\n  //     .setSize(this.width * 2 - this.padding.left - AXIS_INNER_PADDING * 2 - this.padding.right, this.height)\n  //     .render();\n  //   this.animate(duration, this.t0);\n  // }\n\n  // public stopRealtime() {\n  //   cancelAnimationFrame(this.reqAnimation);\n  //   const axisOptions = this.options.axis;\n  //   this.reqAnimation = 0;\n  //   this.coordX = 0;\n  //   this.t0 = 0;\n\n  //   this.xAxis\n  //     .setTickCount(axisOptions.x.tick?.count!)\n  //     .setSize(this.width, this.height)\n  //     .setMinMax(axisOptions.x.min, axisOptions.x.max)\n  //     .render();\n  //   this.realtimeAxisMinX = axisOptions.x.min;\n  //   this.realtimeAxisMaxX = axisOptions.x.max;\n\n  //   this.guide.updateXAxis({ min: axisOptions.x.min });\n\n  //   this.gridAxis\n  //     .setXTickCount(axisOptions.x.tick?.count!)\n  //     .setSize(this.width, this.height)\n  //     .render();\n  //   this.shoot();\n  // }\n}\n"],"names":[],"sourceRoot":""}