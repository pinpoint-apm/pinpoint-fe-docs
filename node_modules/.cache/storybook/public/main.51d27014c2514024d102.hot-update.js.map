{"version":3,"file":"main.51d27014c2514024d102.hot-update.js","mappings":"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;AACA;;AACA;AACA;AACA;AApLA;AAAA;AAAA;AAsLA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAlMA;AAAA;AAAA;AAoMA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA5MA;AAAA;AAAA;AA8MA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAlPA;AAAA;AAAA;AAoPA;;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAKA;AADA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AA3TA;AAAA;AAAA;AA8TA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AA1UA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClBA;AAOA;AAMA;AAGA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AACA;;AAnBA;AAAA;AAAA;AAsBA;AACA;AAvBA;AAAA;AAAA;AA0BA;AACA;AA3BA;AAAA;AAAA;AA8BA;AACA;AA/BA;AAAA;AAAA;AAkCA;AACA;AAnCA;AAAA;AAAA;AAsCA;AACA;AAvCA;AAAA;AAAA;AAyCA;;AACA;AACA;AACA;;AAEA;AACA;AACA;AAKA;AACA;AAKA;AACA;AACA;AACA;AA9DA;AAAA;AAAA;AAiEA;AAAA;AAAA;AACA;AAlEA;AAAA;AAAA;AAqEA;AAAA;AAAA;AACA;AAtEA;AAAA;AAAA;AAyEA;AACA;AAIA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAzFA;AAAA;AAAA;AA4FA;AACA;AACA;AA9FA;AAAA;AAAA;AAiGA;AACA;AACA;AACA;AACA;AArGA;AAAA;AAAA;AAwGA;AACA;AAzGA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AAEA;AAEA;AAAA;;AAAA;;AACA;AAEA;;AAAA;;AAAA;;AAAA;;AACA;;AACA;;AAFA;AAGA;;AANA;AAAA;AAAA;AAQA;;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;;AACA;AACA;AA5BA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AAEA;AAEA;AAAA;;AAAA;;AACA;AAEA;;AAAA;;AAAA;;AAAA;;AACA;;AACA;;AAFA;AAGA;;AANA;AAAA;AAAA;AAQA;;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;AACA;AACA;AAhCA;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACNA;AAEA;AAWA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAEA;AAWA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAEA;AAaA;AAAA;AAAA;AAAA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChFA;AAAA;;AACA;AAEA;AACA","sources":["webpack://@pinpoint-fe/scatter-chart/./src/storybook/index.stories.ts","webpack://@pinpoint-fe/scatter-chart/./src/constants/options.ts","webpack://@pinpoint-fe/scatter-chart/./src/constants/ui.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/Axis.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/GridAxis.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/Guide.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/Layer.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/Legend.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/ScatterChart.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/Viewport.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/XAxis.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/YAxis.ts","webpack://@pinpoint-fe/scatter-chart/./src/utils/draw.ts","webpack://@pinpoint-fe/scatter-chart/./src/utils/helper.ts"],"sourcesContent":["\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import React from 'react';\\n\\nimport { ScatterChart } from '../ui';\\n\\nexport default {\\n  title: 'PINPOINT/Component/ScatterChart',\\n  component: ScatterChart,\\n  argTypes: {\\n    backgroundColor: { control: 'color' },\\n  },\\n};\\n\\nconst Template = (args: any) => {\\n  // You can either use a function to create DOM elements or use a plain html string!\\n  return `<div></div>`;\\n  // return createButton({ label, ...args });\\n};\\n\\nexport const Default = Template.bind({});\\nDefault.args = {\\n};\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Default\":{\"startLoc\":{\"col\":17,\"line\":13},\"endLoc\":{\"col\":1,\"line\":17},\"startBody\":{\"col\":17,\"line\":13},\"endBody\":{\"col\":1,\"line\":17}}};\n    \nimport React from 'react';\n\nimport { ScatterChart } from '../ui';\n\nexport default {\n  title: 'PINPOINT/Component/ScatterChart',\n  component: ScatterChart,\n  argTypes: {\n    backgroundColor: { control: 'color' },\n  },\n};\n\nconst Template = (args: any) => {\n  // You can either use a function to create DOM elements or use a plain html string!\n  return `<div></div>`;\n  // return createButton({ label, ...args });\n};\n\nexport const Default = Template.bind({});\nDefault.args = {\n};\n\n\nDefault.parameters = { storySource: { source: \"(args: any) => {\\n  // You can either use a function to create DOM elements or use a plain html string!\\n  return `<div></div>`;\\n  // return createButton({ label, ...args });\\n}\" }, ...Default.parameters };","import { DataOption, LegendOption, PointOption } from \"../types\";\nimport { AXIS_DEFAULT_TICK_COUNT, POINT_RADIUS } from \"./ui\";\n\nexport const AXIS_DEFAULT_FORMAT = ((value: number) => value);\n\nexport const defaultOption = {};\n\nexport const defaultDataOption: DataOption[] = []\n\nexport const defaultLegendOption: LegendOption = {\n  formatLabel: (label) => label,\n  formatValue: (value) => value,\n}\n\nexport const defaultAxisOption = {\n  x: {\n    min: 0,\n    max: 1,\n    tick: {\n      count: AXIS_DEFAULT_TICK_COUNT,\n      format: AXIS_DEFAULT_FORMAT,\n    }\n  },\n  y: {\n    min: 0,\n    max: 1, \n    tick: {\n      count: AXIS_DEFAULT_TICK_COUNT,\n      format: AXIS_DEFAULT_FORMAT,\n    }\n  }\n}\n\nexport const defaultPointOption: PointOption = {\n  radius: POINT_RADIUS,\n}","export const SCATTER_CHART_IDENTIFIER = '__scatter_chart__';\nexport const PIXEL_RATIO = window && window.devicePixelRatio || 1;\n\n// container \nexport const CONTAINER_WIDTH = 518;\nexport const CONTAINER_HEIGHT = 320;\n\n// axis\nexport const AXIS_INNER_PADDING = 5;\nexport const AXIS_TICK_LENGTH = 4;\nexport const AXIS_DEFAULT_TICK_COUNT = 5;\n\n// tick text\nexport const TEXT_MARGIN_TOP = 1;\nexport const TEXT_MARGIN_BOTTOM = 1;\nexport const TEXT_MARGIN_LEFT = 2;\nexport const TEXT_MARGIN_RIGHT= 2;\n\n// point\nexport const POINT_RADIUS= 3;\n\n// layer\nexport const LAYER_DEFAULT_PRIORITY = 99;","import { AXIS_DEFAULT_FORMAT } from \"../constants/options\";\nimport { AXIS_DEFAULT_TICK_COUNT } from \"../constants/ui\";\nimport { TickOption, FormatType } from \"../types\";\nimport { Layer, LayerProps } from \"./Layer\";\n\nexport interface AxisProps extends LayerProps {\n  min?: number;\n  max?: number;\n  padding?: {\n    top?: number;\n    bottom?: number;\n    left?: number;\n    right?: number;\n  };\n  innerPadding?: number;\n  tickCount?: number;\n  format?: FormatType<number>\n  tickOption?: TickOption;\n};\n\nexport class Axis extends Layer {\n  min;\n  max;\n  padding;\n  tickOption;\n\n  constructor({\n    min = 0,\n    max = 1,\n    padding,\n    tickCount,\n    format,\n    tickOption,\n    ...props\n  }: AxisProps = {}) {\n    super(props);\n\n    this.min = min;\n    this.max = max;\n    this.padding = { top: 0, bottom:0, left: 0, right: 0, ...padding };\n    this.tickOption = { ...{ count: AXIS_DEFAULT_TICK_COUNT, format: AXIS_DEFAULT_FORMAT }, ...tickOption }\n  }\n\n  setMinMax(min: number, max: number) {\n    this.min = min;\n    this.max = max;\n    return this;\n  }\n\n  setSize(...args: Parameters<Layer['setSize']>) {\n    super.setSize(...args);\n    return this;\n  }\n\n  setTickCount(count: number) {\n    this.tickOption = { ...this.tickOption, count };\n    return this;\n  }\n}","import { AXIS_DEFAULT_TICK_COUNT, AXIS_INNER_PADDING, AXIS_TICK_LENGTH } from \"../constants/ui\";\nimport { drawLine, drawText } from \"../utils/draw\";\nimport { Axis, AxisProps } from \"./Axis\";\n\nexport interface GridAxisProps extends AxisProps {\n  xTickCount?: number;\n  yTickCount?: number;\n};\n\nexport class GridAxis extends Axis {\n  xTickCount;\n  yTickCount;\n\n  constructor({\n    xTickCount,\n    yTickCount,\n    ...props\n  }: GridAxisProps = {}) {\n    super(props);\n    this.xTickCount = xTickCount || AXIS_DEFAULT_TICK_COUNT;\n    this.yTickCount = yTickCount || AXIS_DEFAULT_TICK_COUNT;\n    this.render();\n  }\n\n  setXTickCount(tick: number) {\n    this.xTickCount = tick;\n    return this;\n  }\n\n  setYickCount(tick: number) {\n    this.yTickCount = tick;\n    return this;\n  }\n\n  renderXGrid() {\n    const tickCount = this.xTickCount;\n    const padding = this.padding;\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n\n    const startX = padding.left + AXIS_INNER_PADDING;\n    const startY = padding.top;\n    const endX = width - padding.right - AXIS_INNER_PADDING;\n    const endY = height - padding.bottom; \n    const wGap = (endX - startX) / (tickCount - 1);\n\n    [...Array(tickCount)].forEach((_ , i) => {\n      const x = wGap * i + startX;\n      drawLine(this.context, x, startY, x, endY + AXIS_TICK_LENGTH, { color: '#d1d1d1'});\n    })\n  }\n\n  renderYGrid() {\n    const tickCount = this.yTickCount;\n    const padding = this.padding;\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n    \n    const startX = padding.left;\n    const startY = padding.top + AXIS_INNER_PADDING;\n    const endX = width - padding.right + AXIS_INNER_PADDING;\n    const endY = height - padding.bottom - AXIS_INNER_PADDING;\n    const hGap = (endY - startY) / (tickCount - 1);\n\n    [...Array(tickCount)].forEach((_, i) => {\n      const y = hGap * i + startY;\n      drawLine(this.context, startX - AXIS_TICK_LENGTH, y, endX, y, { color: '#d1d1d1'});\n    })\n  }\n\n  public render() {\n    this.clear();\n    this.renderXGrid();\n    this.renderYGrid();    \n  }\n}","import { AXIS_INNER_PADDING, AXIS_TICK_LENGTH, TEXT_MARGIN_BOTTOM, TEXT_MARGIN_LEFT, TEXT_MARGIN_RIGHT, TEXT_MARGIN_TOP } from \"../constants/ui\";\nimport { AxisOption, FormatType, LegendOption } from \"../types\";\nimport { drawLine, drawRect, drawText } from \"../utils/draw\";\nimport { Layer } from \"./Layer\";\n\nexport interface GuideOptions {\n  width: number;\n  height: number;\n  padding: {\n    top: number;\n    right: number;\n    bottom: number;\n    left: number;\n  };\n  ratio: {\n    x: number;\n    y: number;\n  };\n  axisOption: { x: AxisOption, y: AxisOption };\n}\n\nexport class Guide extends Layer {\n  private wrapper;\n  private padding;\n  private ratio;\n  private axis;\n  private isMouseDown = false;\n  private isDragging = false;\n  private dragStartX = 0;\n  private dragStartY = 0;\n  private eventHandlers: {[key: string]: Function} = {};\n\n  constructor(wrapper: HTMLElement, {\n    width, height, padding, ratio, axisOption,\n  }: GuideOptions) {\n    super({ width, height });\n    this.canvas.style.position = 'absolute';\n    this.canvas.style.zIndex = '999';\n    this.canvas.style.top = '0px';\n    this.canvas.style.left = '0px';\n    this.canvas.style.background = 'transparent';\n    this.padding = padding;\n    this.ratio = ratio;\n    this.axis = axisOption;\n    this.wrapper = wrapper;\n    this.wrapper.append(this.canvas);\n    this.addEventListener();\n  }\n\n  private isMouseInValidArea(x: number, y: number) {\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n    const padding = this.padding\n\n    return (\n      x >= padding.left + AXIS_INNER_PADDING &&\n      x <= width - padding.right - AXIS_INNER_PADDING && \n      y >= padding.top + AXIS_INNER_PADDING && \n      y <= height - padding.bottom - AXIS_INNER_PADDING\n    )\n  }\n\n  private addEventListener() {\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n\n    this.canvas.addEventListener('mousedown', ({ offsetX, offsetY }) => {\n      this.isMouseDown = true;\n      this.dragStartX = offsetX;\n      this.dragStartY = offsetY;\n    });\n\n    this.canvas.addEventListener('mousemove', ({ offsetX, offsetY }) => {\n      this.context.clearRect(0, 0, width, height);\n      const x = offsetX;\n      const y = offsetY;\n      if (this.isMouseInValidArea(x, y)) {\n        // vertical line\n        // drawLine(this.context, x , 0, x, height - padding.bottom + AXIS_INNER_PADDING)\n        // horizontal line\n        // drawLine(this.context, padding.left, y, width, y)\n\n        this.drawGuideText(x,y);\n      }\n      if (this.isMouseDown) {\n        this.isDragging = true;\n        drawRect(this.context, \n          this.dragStartX, this.dragStartY, offsetX - this.dragStartX, offsetY - this.dragStartY,\n          {\n            color: 'rgba(225,225,225,0.5)',\n            strokeColor: 'blue',\n          }\n        )\n      }\n    });\n\n    this.canvas.addEventListener('mouseout', event => {\n      this.isMouseDown = false;\n      this.isDragging = false;\n      this.context.clearRect(0, 0, width, height);\n    });\n\n    this.canvas.addEventListener('mouseup', event => {\n      const { offsetX, offsetY } = event;\n      this.context.clearRect(0, 0, width, height);\n      \n      if (this.isDragging) {\n        this.isMouseInValidArea(offsetX, offsetY) && this.drawGuideText(offsetX, offsetY)\n        this.eventHandlers['dragEnd']?.({ \n          x1: this.dragStartX / this.ratio.x + this.axis.x.min,\n          y1: this.axis.y.max - (this.dragStartY - this.padding.top - AXIS_INNER_PADDING) / this.ratio.y,\n          x2: this.axis.y.max - (offsetX - this.padding.top - AXIS_INNER_PADDING) / this.ratio.x + this.axis.x.min,\n          y2: this.axis.y.max - (offsetY - this.padding.top - AXIS_INNER_PADDING) / this.ratio.y,\n        });\n      }\n      this.isMouseDown = false;\n    });\n\n    this.canvas.addEventListener('click', event => {\n      const { offsetX, offsetY } = event;\n      if (!this.isDragging) {\n        this.eventHandlers['click']?.({ \n          x: offsetX / this.ratio.x + this.axis.x.min,\n          y: this.axis.y.max - (offsetY - this.padding.top - AXIS_INNER_PADDING) / this.ratio.y,\n        })\n      }\n      this.isDragging = false;\n    })\n  }\n\n  private drawGuideText(x: number, y: number) {\n    const { padding, context, canvas, ratio, axis } = this;\n    const height = canvas.height / this.dpr;\n    const xText = `${axis.x.tick?.format!((x - padding.left - AXIS_INNER_PADDING) / ratio.x + axis.x.min)}`;\n    const yText = `${axis.y.tick?.format!(Math.floor(Math.abs((height - padding.bottom - AXIS_INNER_PADDING - y) / ratio.y)))}`;\n    \n    // x\n    const xTextWidth = this.getTextWidth(xText) + TEXT_MARGIN_LEFT + TEXT_MARGIN_RIGHT;\n    const xTextHeight = this.getTextHeight(xText) + TEXT_MARGIN_TOP + TEXT_MARGIN_BOTTOM;\n    // y\n    const yTextWidth = this.getTextWidth(yText) + TEXT_MARGIN_LEFT + TEXT_MARGIN_RIGHT;\n    const yTextHeight = this.getTextHeight(yText) + TEXT_MARGIN_TOP + TEXT_MARGIN_BOTTOM;\n\n    // x\n    drawRect(context, x - xTextWidth / 2, height - padding.bottom + AXIS_TICK_LENGTH, xTextWidth, xTextHeight, { color: 'black' });\n    drawLine(context, padding.left - AXIS_TICK_LENGTH, y, padding.left, y);\n    drawText(context, xText, x, height - TEXT_MARGIN_BOTTOM, { color: 'white', textAlign: 'center', textBaseline: 'bottom' });\n    // y\n    drawRect(context, padding.left - AXIS_TICK_LENGTH - yTextWidth, y - yTextHeight / 2, yTextWidth, yTextHeight, { color: 'black' });\n    drawLine(context, x, height - padding.bottom, x, height - padding.bottom + AXIS_TICK_LENGTH);\n    drawText(context, yText, padding.left - AXIS_TICK_LENGTH - TEXT_MARGIN_RIGHT, y + 3, { color: 'white', textAlign: 'end' });\n    \n  }\n\n  public updateXAxis(x: Partial<AxisOption['x']>) {\n    this.axis = {...this.axis, ...{ x: {...this.axis.x, ...x}}}\n  }\n\n  public on(evetntType: string, callback: (data: any) => void) {\n    this.eventHandlers[evetntType] = callback;\n  }\n}","import { LAYER_DEFAULT_PRIORITY } from \"../constants/ui\";\nimport { Coord } from \"../types\";\nimport { getDevicePicelRatio } from \"../utils/helper\";\n\nexport interface LayerProps {\n  width?: number;\n  height?: number;\n  display?: boolean;\n  fixed?: boolean;\n  priority?: number;\n}\n\nexport class Layer {\n  private cvs: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private identifier: string = '';\n  private display;\n  private fixed;\n  private priorityOrder;\n  private displayPixcelRatio;\n\n  constructor({\n     width = 0,\n     height = 0,\n     display = true,\n     fixed = false,\n     priority = LAYER_DEFAULT_PRIORITY,\n  }: LayerProps = {}) {\n    this.displayPixcelRatio = getDevicePicelRatio();\n    this.display = display;\n    this.fixed = fixed;\n    this.priorityOrder = priority;\n    this.cvs = document.createElement('canvas');\n    this.ctx = this.cvs.getContext('2d')!;\n    this.cvs.style.width = `${width}px`;\n    this.cvs.style.height = `${height}px`;\n    this.cvs.width = width * this.dpr;\n    this.cvs.height = height * this.dpr;\n    this.ctx.scale(this.dpr, this.dpr);\n  }\n\n  public setSize(width: number, height: number) {\n    this.cvs.style.width = `${width}px`;\n    this.cvs.style.height = `${height}px`;\n    this.cvs.width = width * this.dpr;\n    this.cvs.height = height * this.dpr;\n    this.ctx.scale(this.dpr, this.dpr);\n  }\n\n  public show() {\n    this.display = true;\n  }\n\n  public hide() {\n    this.display = false;\n  }\n\n  public clear() {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  get dpr() {\n    return this.displayPixcelRatio;\n  }\n\n  get priority() {\n    return this.priorityOrder;\n  }\n\n  set priority(priority: number) {\n    this.priorityOrder = priority;\n  }\n\n  get id() {\n    return this.identifier;\n  }\n\n  set id(id: string) {\n    this.identifier = id;\n  }\n\n  get isFixed() {\n    return this.fixed;\n  }\n\n  set isFixed(fixed: boolean) {\n    this.fixed = fixed;\n  }\n\n  get canvas() {\n    return this.cvs; \n  }\n\n  get context() {\n    return this.ctx;\n  }\n\n  get isDisplay() {\n    return this.display;\n  }\n\n  public swapCanvasImage() {\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n    const rightImage = this.getCroppedImage(this.ctx, { x: width, y: 0 }, { x: width * 2, y: height });\n    this.ctx.clearRect(0, 0, width, height);\n    this.ctx.putImageData(rightImage, 0, 0)\n  }\n\n  public getCroppedImage(ctx: CanvasRenderingContext2D, lCoord: Coord, rCoord: Coord) {\n    return ctx.getImageData(lCoord.x, lCoord.y, rCoord.x, rCoord.y);\n  }\n\n  public getTextWidth(text: string | number) {\n    return this.context.measureText(`${text}`).width;\n  }\n\n  public getTextHeight(text: string | number) {\n    const metrics = this.context.measureText(`${text}`);\n    let fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;\n    let actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n\n    return fontHeight;\n  }\n}","import { SCATTER_CHART_IDENTIFIER } from \"../constants/ui\";\nimport { LegendOption } from \"../types\";\n\nexport type LegendProps = { \n  types: string[], \n  legendOptions: LegendOption, \n  dataColorMap: {[key: string]: string},\n}\nexport class Legend {\n  static LEGEND_CLASS = `${SCATTER_CHART_IDENTIFIER}legend`;\n  static MARK_CLASS = `${Legend.LEGEND_CLASS}_mark`;\n  static COUNT_CLASS = `${Legend.LEGEND_CLASS}_count`;\n  private rootWrapper;\n  private types;\n  private options;\n  private dataColorMap;\n  private containerElement: HTMLElement;\n  private legendElements: {[key: string]: HTMLDivElement} = {} \n  \n  constructor(rootWrapper: HTMLElement, { types, legendOptions, dataColorMap }: LegendProps) {\n    this.rootWrapper = rootWrapper;\n    this.types = types;\n    this.options = legendOptions;\n    this.dataColorMap = dataColorMap;\n    this.containerElement = document.createElement('div');\n    this.containerElement.className = `${SCATTER_CHART_IDENTIFIER}legend_container`;\n  }\n\n  addEvents(callback?: ({ type, checked }: { type: string, checked: boolean}) => void) {\n    this.containerElement.addEventListener('click', (event) => {\n      const isInputNode = event.target.nodeName === 'INPUT';\n      const wrapper = event.target.closest('div');\n      const checkbox = wrapper.querySelector('input');\n\n      if (isInputNode) {\n        callback?.({ type: wrapper.dataset.name, checked: checkbox.checked });\n      }\n    });\n    return this;\n  }\n\n  render() {\n    const options = this.options;\n    const dataTypes = this.types;\n\n    dataTypes.forEach(type => {\n      // wrapper div\n      const legendWrapper = document.createElement('div');\n      legendWrapper.dataset.name = type;\n      legendWrapper.className = `${Legend.LEGEND_CLASS} ${type}`;\n\n      // mark\n      const markElement = document.createElement('span');\n      markElement.style.background = this.dataColorMap[type];\n      // const formattedLabel = options?.formatLabel?.(type) || type;\n      markElement.className = Legend.MARK_CLASS;\n\n      // count span\n      const countElement = document.createElement('span');\n      countElement.className = Legend.COUNT_CLASS;\n\n      // label\n      const labelElement = document.createElement('label');\n      const formattedLabel = options?.formatLabel?.(type) || type;\n      labelElement.htmlFor = `${Legend.LEGEND_CLASS}_${type}_input`;\n      labelElement.append(`${formattedLabel}`, countElement);\n\n\n      // input\n      const inputElement = document.createElement('input');\n      inputElement.id = `${Legend.LEGEND_CLASS}_${type}_input`;\n      inputElement.type = 'checkbox';\n      inputElement.checked = true;\n\n      this.legendElements[type] = legendWrapper;\n\n      legendWrapper.append(markElement, labelElement, inputElement);\n      this.containerElement.append(legendWrapper);\n    })\n    this.rootWrapper.append(this.containerElement);\n  }\n\n  setLegendCount(type: string, value: number) {\n    const legendElement = this.legendElements[type];\n    const countElement = legendElement.getElementsByClassName(Legend.COUNT_CLASS)[0];\n\n    countElement.innerHTML = `${this.options.formatValue?.(value)}`;\n  }\n}","import { AxisOption, DataOption, LegendOption, ScatterDataType } from \"../types\";\nimport { Layer } from \"./Layer\";\nimport { Viewport } from \"./Viewport\";\nimport { drawCircle } from \"../utils/draw\";\nimport { YAxis } from \"./YAxis\";\nimport { XAxis } from \"./XAxis\";\nimport { AXIS_INNER_PADDING, AXIS_TICK_LENGTH, CONTAINER_HEIGHT, CONTAINER_WIDTH, LAYER_DEFAULT_PRIORITY, TEXT_MARGIN_BOTTOM, TEXT_MARGIN_LEFT, TEXT_MARGIN_RIGHT, TEXT_MARGIN_TOP } from \"../constants/ui\";\nimport { GridAxis } from \"./GridAxis\";\nimport { Legend } from \"./Legend\";\nimport { Guide } from \"./Guide\";\nimport { defaultAxisOption, defaultDataOption, defaultLegendOption } from \"../constants/options\";\n\nexport interface ScatterChartOption {\n  axis: { x: AxisOption, y: AxisOption };\n  data: DataOption[];\n  legend?: LegendOption;\n}\n\nexport class ScatterChart {\n  private wrapper;\n  private canvasWrapper;\n  private options!: ScatterChartOption;\n  private xAxis!: XAxis;\n  private yAxis!: YAxis;\n  private gridAxis!: GridAxis;\n  private legend!: Legend;\n  private dataColorMap!: { [key: string]: string };\n  private viewport!: Viewport;\n  private guide!: Guide;\n  private layers: { [key: string]: Layer } = {};\n  private datas: {[key: string]: number[]} = {};\n  private xRatio = 1;\n  private yRatio = 1;\n  private coordX = 0;\n  private coordY = 0;\n  private realtimeAxisMinX = 0;\n  private realtimeAxisMaxX = 0;\n  private width = 0;\n  private height = 0;\n  private padding = {\n    top: 15,\n    bottom: 20,\n    left: 0,\n    right: 0,\n  }\n  private t0: number = 0;\n  private reqAnimation = 0;\n\n  constructor(wrapper: HTMLElement, options: ScatterChartOption) {\n    this.wrapper = wrapper;\n    this.canvasWrapper = document.createElement('div');\n    this.canvasWrapper.style.position = 'relative';\n    this.wrapper.append(this.canvasWrapper);\n\n    this.setOptions(options);\n    this.setWrapperSize();\n    this.setViewPort();\n    this.setPadding();\n    this.setRatio();\n    this.setAxis();\n    this.setGuide();\n    this.setLayers();\n    this.setLegends();\n\n    this.animate = this.animate.bind(this);\n  }\n\n  private setOptions(options: ScatterChartOption) {\n    this.options = {\n      // TODO deep copy\n      axis: { ...defaultAxisOption, ...options.axis },\n      data: [...defaultDataOption, ...options.data],\n      legend: { ...defaultLegendOption, ...options.legend },\n    };\n\n    this.dataColorMap = this.options.data.reduce((prev, curr) => {\n      return {\n        [curr.type]: curr.color,\n        ...prev,\n      }\n    }, {});\n  }\n\n  private setWrapperSize() {\n    this.width = this.wrapper.clientWidth || CONTAINER_WIDTH;\n    this.height = this.wrapper.clientHeight || CONTAINER_HEIGHT;\n  }\n\n  private setPadding() {\n    const xformatter = this.options.axis.x.tick?.format;\n    const yformatter = this.options.axis.y.tick?.format;\n    const formattedMaxX = xformatter ? xformatter(this.options.axis.x.max) : this.options.axis.x.max;\n    const formattedMaxY = yformatter ? yformatter(this.options.axis.y.max) : this.options.axis.y.max;\n    const maxXWidth = this.viewport.viewLayer.getTextWidth(formattedMaxX);\n    const maxYWidth = this.viewport.viewLayer.getTextWidth(formattedMaxY);\n\n    this.padding.left = (maxXWidth / 2 > maxYWidth ? maxXWidth / 2 : maxYWidth) + TEXT_MARGIN_LEFT + TEXT_MARGIN_RIGHT + AXIS_TICK_LENGTH;\n    this.padding.right = maxXWidth / 2 + TEXT_MARGIN_RIGHT;\n    this.padding.bottom = this.viewport.viewLayer.getTextHeight(formattedMaxX) + TEXT_MARGIN_TOP + TEXT_MARGIN_BOTTOM + AXIS_TICK_LENGTH;\n  }\n\n  private setViewPort() {\n    this.viewport = new Viewport(\n      this.canvasWrapper,\n      { width: this.width, height: this.height }\n    );\n  }\n\n  private setGuide() {\n    this.guide = new Guide(\n      this.canvasWrapper,\n      { \n        width: this.width, \n        height: this.height, \n        padding: this.padding, \n        axisOption: this.options.axis,\n        ratio: {\n          x: this.xRatio,\n          y: this.yRatio,\n        }\n      }\n    )\n  }\n\n  private setAxis() {\n    const options = this.options;\n\n    this.yAxis = new YAxis({\n      min: options.axis.y.min,\n      max: options.axis.y.max,\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: -2,\n      fixed: true,\n      tickOption: options.axis.y.tick,\n    });\n\n    this.xAxis = new XAxis({\n      min: options.axis.x.min,\n      max: options.axis.x.max,\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: -1,\n      tickOption: options.axis.x.tick,\n    });\n\n    this.gridAxis = new GridAxis({\n      min: options.axis.x.min,\n      max: options.axis.x.max,\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: 9999,\n      xTickCount: options.axis.x.tick?.count,\n      yTickCount: options.axis.y.tick?.count,\n    })\n\n    this.viewport.addLayer(this.yAxis);\n    this.viewport.addLayer(this.xAxis);\n    this.viewport.addLayer(this.gridAxis);\n  }\n\n  private setLayers() {\n    const width = this.viewport.styleWidth;\n    const height = this.viewport.styleHeight;\n    const dataOptions = this.options.data;\n\n    dataOptions.forEach(({ type, priority = LAYER_DEFAULT_PRIORITY }) => {\n      this.setLayer(type, width, height, priority);\n    })\n  }\n\n  private setLayer(legend: string, width: number, height: number, priority: number) {\n    const layer = new Layer({ width, height });\n    layer.id = legend;\n    layer.priority = priority;\n    this.layers[legend] = layer;\n    this.viewport.addLayer(layer);\n  }\n\n  private setLegends() {\n    this.legend = new Legend(this.wrapper, { \n      types: Object.keys(this.layers), \n      dataColorMap: this.dataColorMap,\n      legendOptions: this.options?.legend!\n    });\n    this.legend.addEvents(({ type, checked }) => {\n      if (type) {\n        if (checked) {\n          this.viewport.showLayer(type);\n        } else {\n          this.viewport.hideLayer(type);\n        }\n      }\n      this.shoot();\n    }).render();\n  }\n\n  private setRatio() {\n    const axis = this.options?.axis;\n    const padding = this.padding;\n    const width = this.viewport.canvas.width / this.viewport.viewLayer.dpr;\n    const height = this.viewport.canvas.height / this.viewport.viewLayer.dpr;\n    const minX = axis.x.min;\n    const maxX = axis.x.max;\n    const minY = axis.y.min;\n    const maxY = axis.y.max;\n\n    this.xRatio = (width - padding.left - padding.right - AXIS_INNER_PADDING * 2) / (maxX - minX);\n    this.yRatio = (height - padding.bottom - padding.top - AXIS_INNER_PADDING * 2) / (maxY - minY);\n  }\n\n  private shoot() {\n    this.viewport.clear();\n    this.viewport.render(this.coordX, this.coordY);\n    \n    Object.keys(this.datas).forEach(key => {\n      // this.datas[key].sort((a,b) => a - b);\n      this.legend.setLegendCount(key, this.datas[key].length);\n    })\n  }\n\n  private animate(duration: number, now: number) {\n    this.shoot();\n    if (!this.t0) this.t0 = now;\n    const dt = now - this.t0;\n    const pixcelPerFrame = (this.viewport.styleWidth - this.padding.left - this.padding.right - AXIS_INNER_PADDING * 2) / duration * dt;\n    const pixcelPerSecond = pixcelPerFrame * 60;\n\n    this.t0 = now;\n    this.coordX = this.coordX - pixcelPerFrame;\n\n    // 특정 주기마다 시행\n    if (Math.abs(Math.floor(this.coordX)) % (Math.floor(pixcelPerSecond / 5)) === 0) {\n      const x = Math.abs(this.coordX) / this.xRatio;\n      Object.keys(this.datas).forEach(key => {\n        this.datas[key] = this.datas[key].filter(d => d > x);\n      })\n\n      this.guide.updateXAxis({ min: x + this.xAxis.min});\n    }\n\n    if (this.coordX > -(this.viewport.styleWidth - this.padding.left - this.padding.right - AXIS_INNER_PADDING * 2)) {\n      this.reqAnimation = requestAnimationFrame((t) => this.animate(duration, t))\n    } else {\n      // swap\n      const nextAxisMinX = this.realtimeAxisMinX + (this.realtimeAxisMaxX - this.realtimeAxisMinX) / 2;\n      const nextAxisMaxX = this.realtimeAxisMaxX + (this.realtimeAxisMaxX - this.realtimeAxisMinX) / 2;\n      this.realtimeAxisMinX = nextAxisMinX;\n      this.realtimeAxisMaxX = nextAxisMaxX;\n      this.coordX = 0;\n\n      this.xAxis\n        .setMinMax(this.realtimeAxisMinX, this.realtimeAxisMaxX)\n        .render();\n      Object.values(this.layers).filter(layer => !layer.isFixed).forEach(layer =>  layer.swapCanvasImage());\n      this.reqAnimation = requestAnimationFrame((t) => this.animate(duration, t))\n    }\n  }\n\n  public render(data: ScatterDataType[], { append = false } = {}) {\n    this.setRatio();\n    const { styleWidth, styleHeight } = this.viewport;\n    const padding = this.padding;\n\n    !append && this.viewport.clear();\n    data.forEach(({ x, y, type, hidden }, i) => {\n      const legend = type ? type : 'unknown';\n      \n      if (!this.layers[legend]) {\n        this.setLayer(legend, styleWidth, styleHeight, LAYER_DEFAULT_PRIORITY);\n      }\n\n      if (this.datas[legend]) {\n        this.datas[legend].push(x);\n      } else {\n        this.datas[legend] = [x];\n      }\n\n      !hidden && drawCircle(\n        this.layers[legend].context,\n        this.xRatio * x + padding.left + AXIS_INNER_PADDING,\n        this.viewport.canvas.height / this.viewport.viewLayer.dpr - this.yRatio * y - padding.bottom - AXIS_INNER_PADDING,\n        {\n          fillColor: this.dataColorMap[legend],\n        }\n      );\n    });\n    this.shoot();\n  }\n\n  // public startRealtime(duration: number) {\n  //   if (this.reqAnimation) return;\n  //   const axisOptions = this.options.axis;\n  //   this.xAxis\n  //     .setTickCount(axisOptions.x.tick?.count! * 2 - 1)\n  //     .setSize(this.width * 2 - this.padding.left - AXIS_INNER_PADDING * 2 - this.padding.right, this.height)\n  //     .setMinMax(axisOptions.x.min, axisOptions.x.max * 2 - axisOptions.x.min)\n  //     .render();\n  //   this.realtimeAxisMinX = axisOptions.x.min;\n  //   this.realtimeAxisMaxX = axisOptions.x.max * 2 - axisOptions.x.min;\n\n  //   this.gridAxis\n  //     .setXTickCount(axisOptions.x.tick?.count! * 2 - 1)\n  //     .setSize(this.width * 2 - this.padding.left - AXIS_INNER_PADDING * 2 - this.padding.right, this.height)\n  //     .render();\n  //   this.animate(duration, this.t0);\n  // }\n\n  // public stopRealtime() {\n  //   cancelAnimationFrame(this.reqAnimation);\n  //   const axisOptions = this.options.axis;\n  //   this.reqAnimation = 0;\n  //   this.coordX = 0;\n  //   this.t0 = 0;\n\n  //   this.xAxis\n  //     .setTickCount(axisOptions.x.tick?.count!)\n  //     .setSize(this.width, this.height)\n  //     .setMinMax(axisOptions.x.min, axisOptions.x.max)\n  //     .render();\n  //   this.realtimeAxisMinX = axisOptions.x.min;\n  //   this.realtimeAxisMaxX = axisOptions.x.max;\n\n  //   this.guide.updateXAxis({ min: axisOptions.x.min });\n\n  //   this.gridAxis\n  //     .setXTickCount(axisOptions.x.tick?.count!)\n  //     .setSize(this.width, this.height)\n  //     .render();\n  //   this.shoot();\n  // }\n\n  public on(evetntType: string, callback: (data: any) => void) {\n    this.guide.on(evetntType, callback);\n  }\n\n  // swapPaperCanvasImage(ctx: CanvasRenderingContext2D) {\n  //   // const leftImage = this.getCroppedImage(ctx, { x: 0, y: 0 }, { x: 400, y: 400 });\n  //   const rightImage = this.getCroppedImage(ctx, { x: 400, y: 0 }, { x: 800, y: 400 });\n  //   ctx.clearRect(0, 0, this.viewport.styleWidth, this.viewport.styleHeight);\n  //   ctx.putImageData(rightImage, 0, 0)\n  // }\n\n  // getCroppedImage(ctx: CanvasRenderingContext2D, lCoord: Coord, rCoord: Coord) {\n  //   return ctx.getImageData(lCoord.x, lCoord.y, rCoord.x, rCoord.y);\n  // }\n}\n","import { Layer } from \"./Layer\";\n\nexport interface ViewportOption {\n  width: number;\n  height: number;\n}\n\nexport class Viewport {\n  private view: Layer;\n  private layers: Layer[];\n  private width: number;\n  private height: number;\n  \n  constructor(wrapper: HTMLElement, {\n    width = 0,\n    height = 0,\n  }) {\n    this.width = width;\n    this.height = height;\n    this.layers = []\n    \n    this.view = new Layer({\n      width, \n      height,\n    });\n    wrapper.append(this.view.canvas);\n  }\n\n  get viewLayer() {\n    return this.view;\n  }\n\n  get canvas() {\n    return this.view.canvas;\n  }\n\n  get context() {\n    return this.view.context;\n  }\n\n  get styleWidth() {\n    return this.width;\n  }\n\n  get styleHeight() {\n    return this.height;  \n  }\n\n  public render(x: number, y: number) {\n    this.layers.forEach(layer => {\n      const layerCanvas = layer.canvas;\n      const dpr = layer.dpr;\n      \n      if (layer.isDisplay) {\n        if (layer.isFixed) {\n          this.view.context.drawImage(\n            layerCanvas, \n            0, 0, layerCanvas.width, layerCanvas.height, \n            0, 0, layerCanvas.width / dpr, layerCanvas.height / dpr\n          );\n        } else {\n          this.view.context.drawImage(\n            layerCanvas, \n            -x * dpr, y * dpr, layerCanvas.width, layerCanvas.height,\n            0, y, layerCanvas.width / dpr, layerCanvas.height / dpr\n          );\n        }\n      } \n    })\n  }\n\n  public hideLayer(id: string) {\n    this.layers.filter(layer => layer.id === id)[0].hide();\n  }\n\n  public showLayer(id: string) {\n    this.layers.filter(layer => layer.id === id)[0].show();\n  }\n\n  public addLayer(layer: Layer | Layer[]) {\n    if (Array.isArray(layer)) {\n      this.layers = [\n        ...this.layers,\n        ...layer,\n      ];\n    } else {\n      this.layers.push(layer);\n    }\n    this.layers.sort((a, b) => {\n      if (a.priority > b.priority) {\n        return -1;\n      } else \n        return 1;\n    })\n    console.log(this.layers);\n    return this;\n  }\n\n  public setSize(width: number, height: number) {\n    this.view.setSize(width, height);\n    return this;\n  } \n\n  public setLayersSize(width: number, height: number) {\n    this.layers.forEach(layer => {\n      layer.setSize(width, height);\n    });\n    return this;\n  }\n\n  public clear() {\n    this.view.context.clearRect(0, 0, this.view.canvas.width, this.view.canvas.height);\n  }\n}","import { AXIS_INNER_PADDING, AXIS_TICK_LENGTH, TEXT_MARGIN_BOTTOM } from \"../constants/ui\";\nimport { drawLine, drawText } from \"../utils/draw\";\nimport { Axis, AxisProps } from \"./Axis\";\n\nexport interface XAxisProps extends AxisProps {};\n\nexport class XAxis extends Axis {\n  constructor({\n    ...props\n  }: XAxisProps = {}) {\n    super(props);\n    this.render();\n  }\n\n  public render() {\n    this.clear();\n    const { format, count } = this.tickOption;\n    const padding = this.padding;\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n\n    const startX = padding.left + AXIS_INNER_PADDING;\n    const endX = width - padding.right - AXIS_INNER_PADDING;\n    const endY = height - padding.bottom; \n    const wGap = (endX - startX) / (count - 1);\n    const xTickGap = (this.max - this.min) / (count - 1);\n\n    [...Array(count)].forEach((_ , i) => {\n      const x = wGap * i + startX;\n      const label = format(xTickGap * i + this.min)\n      drawText(this.context, `${label}`, x, height - TEXT_MARGIN_BOTTOM, { textAlign: 'center', textBaseline: 'bottom' });\n      drawLine(this.context, x, endY, x, endY + AXIS_TICK_LENGTH);\n    })\n    drawLine(this.context, startX - AXIS_INNER_PADDING, endY, endX  + AXIS_INNER_PADDING, endY);\n  }\n}","import { AXIS_INNER_PADDING, AXIS_TICK_LENGTH, TEXT_MARGIN_LEFT, TEXT_MARGIN_RIGHT } from \"../constants/ui\";\nimport { drawLine, drawRect, drawText } from \"../utils/draw\";\nimport { Axis, AxisProps } from \"./Axis\";\n\nexport interface YAxisProps extends AxisProps {};\n\nexport class YAxis extends Axis {\n  constructor({\n    ...props\n  }: YAxisProps = {}) {\n    super(props);\n    this.render();\n  }\n\n  public render() {\n    const { count, format } = this.tickOption;\n    const padding = this.padding;\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n    \n    const startX = padding.left;\n    const startY = padding.top + AXIS_INNER_PADDING;\n    const endY = height - padding.bottom - AXIS_INNER_PADDING;\n    const hGap = (endY - startY) / (count - 1);\n    const yTickGap = (this.max - this.min) / (count - 1);\n\n\n    drawRect(this.context, 0, 0, padding.left, endY + AXIS_INNER_PADDING + AXIS_TICK_LENGTH);\n    drawRect(this.context, width - padding.right, 0, width, endY + AXIS_INNER_PADDING + AXIS_TICK_LENGTH);\n    drawRect(this.context, 0, 0, width, padding.top);\n    \n    [...Array(count)].forEach((_, i) => {\n      const y = hGap * i + startY;\n      const label = format(yTickGap * (count - 1 - i))\n      drawLine(this.context, startX - AXIS_TICK_LENGTH, y, startX, y);\n      drawText(this.context, `${label}`, startX - TEXT_MARGIN_RIGHT - AXIS_TICK_LENGTH, y + 3, { textAlign: 'end' });\n    })\n    drawLine(this.context, startX, startY - AXIS_INNER_PADDING, startX, endY + AXIS_INNER_PADDING);\n  }\n}","import { defaultPointOption } from \"../constants/options\";\n\nexport const drawCircle = (\n  ctx: CanvasRenderingContext2D, \n  x: number, \n  y: number, \n  { \n    radius = defaultPointOption.radius!,\n    fillColor = 'black',\n  }: { \n    radius?: number,\n    fillColor?: string,\n  } = {}\n) => {\n  ctx.beginPath()\n  ctx.arc(x, y, radius, 0, radius * Math.PI);\n  ctx.fillStyle = fillColor;\n  ctx.fill();\n}\n\nexport const drawLine = (\n  ctx: CanvasRenderingContext2D,\n  fromX: number,\n  fromY: number,\n  toX: number,\n  toY: number,\n  { \n    color = 'black', \n  }: { \n    color?: string \n  } = {}\n) => {\n  ctx.beginPath();\n  ctx.moveTo(fromX, fromY);\n  ctx.lineTo(toX, toY);\n  ctx.strokeStyle = color;\n  ctx.stroke();\n}\n\nexport const drawText = (\n  ctx: CanvasRenderingContext2D,\n  text: string,\n  x: number,\n  y: number,\n  {\n    color = 'black',\n    textAlign = 'center',\n    textBaseline = 'alphabetic',\n  }: { \n    color?: string,\n    textAlign?: CanvasTextAlign,\n    textBaseline?: CanvasTextBaseline,\n  } = {}\n) => {\n  ctx.textAlign = textAlign; \n  ctx.textBaseline = textBaseline; \n  ctx.fillStyle = color;\n  ctx.fillText(text, x, y);\n}\n\nexport const drawRect = (\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  { \n    color = 'white',\n    strokeColor,\n  }: {\n    color?: string,\n    strokeColor?: string,\n  } = {}\n) => {\n  ctx.fillStyle = color;\n  ctx.fillRect(x, y, width, height);\n  if (strokeColor) {\n    ctx.strokeStyle = strokeColor;\n    ctx.strokeRect(x, y, width, height);        \n  }\n}","export const getDevicePicelRatio = () => {\n  const dpr = window?.devicePixelRatio || 2;\n\n  return dpr;\n}"],"names":[],"sourceRoot":""}