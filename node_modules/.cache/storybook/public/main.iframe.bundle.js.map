{"version":3,"file":"main.iframe.bundle.js","mappings":";;;;;;;;;;;;;;;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAFA;AADA;AAFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAEA;;;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AApEA;AAsEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjFA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AA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AACA;AACA;AACA;AAFA;AALA;AAWA;AAvGA;AAAA;AAAA;AAyGA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AASA;AACA;AACA;AACA;AAzIA;AAAA;AAAA;AA2IA;;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AAnJA;AAAA;AAAA;AAsJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AA3JA;AAAA;AAAA;AA6JA;AAAA;;AACA;AACA;AACA;AACA;AAHA;AAKA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AA7KA;AAAA;AAAA;AA+KA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA3LA;AAAA;AAAA;AA6LA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AArMA;AAAA;AAAA;AAuMA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AA3OA;AAAA;AAAA;AA6OA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAKA;AADA;AAIA;AACA;AACA;AAjRA;AAAA;AAAA;AAoRA;AACA;AArRA;AAAA;AAAA;AAwRA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAHA;AAKA;AAAA;AAAA;AACA;AACA;AACA;AAxSA;AAAA;AAAA;A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;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACRA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://@pinpoint-fe/scatter-chart/./.storybook/preview.js","webpack://@pinpoint-fe/scatter-chart/./.storybook/preview.js-generated-config-entry.js","webpack://@pinpoint-fe/scatter-chart/./src/stories/index.stories.ts","webpack://@pinpoint-fe/scatter-chart/./src/constants/options.ts","webpack://@pinpoint-fe/scatter-chart/./src/constants/ui.ts","webpack://@pinpoint-fe/scatter-chart/./src/stories/templates/createAppendDatas.ts","webpack://@pinpoint-fe/scatter-chart/./src/stories/templates/createCaptureImage.ts","webpack://@pinpoint-fe/scatter-chart/./src/stories/templates/createDefault.ts","webpack://@pinpoint-fe/scatter-chart/./src/stories/templates/createResizable.ts","webpack://@pinpoint-fe/scatter-chart/./src/stories/templates/createSetAxis.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/Axis.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/GridAxis.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/Guide.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/Layer.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/Legend.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/ScatterChart.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/Viewport.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/XAxis.ts","webpack://@pinpoint-fe/scatter-chart/./src/ui/YAxis.ts","webpack://@pinpoint-fe/scatter-chart/./src/utils/draw.ts","webpack://@pinpoint-fe/scatter-chart/./src/utils/helper.ts","webpack://@pinpoint-fe/scatter-chart/./src/style/index.css","webpack://@pinpoint-fe/scatter-chart/./src/style/index.css?2688","webpack://@pinpoint-fe/scatter-chart/./src/stories/ sync ^\\.(?6e7a","webpack://@pinpoint-fe/scatter-chart/./src/stories/ sync ^\\.(","webpack://@pinpoint-fe/scatter-chart/ignored|/Users/dy/dy/projects/pinpoint/web/src/main/web-frontend/node_modules/object-inspect|./util.inspect","webpack://@pinpoint-fe/scatter-chart/./generated-stories-entry.cjs"],"sourcesContent":["import '../src/style/index.css';\n\nexport const parameters = {\n  actions: { argTypesRegex: \"^on[A-Z].*\" },\n  controls: {\n    matchers: {\n      color: /(background|color)$/i,\n      date: /Date$/,\n    },\n  },\n}","function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable import/no-unresolved */\nimport { addDecorator, addParameters, addLoader, addArgs, addArgTypes, addArgsEnhancer, addArgTypesEnhancer, setGlobalRender } from '/Users/dy/dy/projects/pinpoint/web/src/main/web-frontend/packages/scatter-chart/node_modules/@storybook/client-api';\nimport * as config from '/Users/dy/dy/projects/pinpoint/web/src/main/web-frontend/packages/scatter-chart/.storybook/preview.js';\nObject.keys(config).forEach(function (key) {\n  var value = config[key];\n\n  switch (key) {\n    case 'args':\n      {\n        return addArgs(value);\n      }\n\n    case 'argTypes':\n      {\n        return addArgTypes(value);\n      }\n\n    case 'decorators':\n      {\n        return value.forEach(function (decorator) {\n          return addDecorator(decorator, false);\n        });\n      }\n\n    case 'loaders':\n      {\n        return value.forEach(function (loader) {\n          return addLoader(loader, false);\n        });\n      }\n\n    case 'parameters':\n      {\n        return addParameters(_objectSpread({}, value), false);\n      }\n\n    case 'argTypesEnhancers':\n      {\n        return value.forEach(function (enhancer) {\n          return addArgTypesEnhancer(enhancer);\n        });\n      }\n\n    case 'argsEnhancers':\n      {\n        return value.forEach(function (enhancer) {\n          return addArgsEnhancer(enhancer);\n        });\n      }\n\n    case 'render':\n      {\n        return setGlobalRender(value);\n      }\n\n    case 'globals':\n    case 'globalTypes':\n      {\n        var v = {};\n        v[key] = value;\n        return addParameters(v, false);\n      }\n\n    case '__namedExportsOrder':\n    case 'decorateStory':\n    case 'renderToDOM':\n      {\n        return null; // This key is not handled directly in v6 mode.\n      }\n\n    default:\n      {\n        // eslint-disable-next-line prefer-template\n        return console.log(key + ' was not supported :( !');\n      }\n  }\n});","\n    /* eslint-disable */\n    // @ts-nocheck\n    // @ts-ignore\n    var __STORY__ = \"import { createAppendDatas } from './templates/createAppendDatas';\\nimport { createCaptureIamge } from './templates/createCaptureImage';\\nimport { createDefault } from './templates/createDefault';\\nimport { createResizable } from './templates/createResizable';\\nimport { createSetAxis } from './templates/createSetAxis';\\n\\n// More on default export: https://storybook.js.org/docs/html/writing-stories/introduction#default-export\\nexport default {\\n  title: 'ScatterChart',\\n  // More on argTypes: https://storybook.js.org/docs/html/api/argtypes\\n  argTypes: {\\n    // backgroundColor: { control: 'color' },\\n    // label: { control: 'text' },\\n    // onClick: { action: 'onClick' },\\n    // primary: { control: 'boolean' },\\n    // size: {\\n    //   control: { type: 'select' },\\n    //   options: ['small', 'medium', 'large'],\\n    // },\\n  },\\n};\\n\\n// More on component templates: https://storybook.js.org/docs/html/writing-stories/introduction#using-args\\nconst TemplateDefault = () => createDefault();\\nexport const Defatult = TemplateDefault.bind({});\\n\\nconst TemplateAppendDatas = () => createAppendDatas();\\nexport const AppendDatas = TemplateAppendDatas.bind({});\\n\\nconst TemplateResize = () => createResizable();\\nexport const Resize = TemplateResize.bind({});\\n\\nconst TemplateSetAxis = () => createSetAxis();\\nexport const SetAxis = TemplateSetAxis.bind({});\\n\\nconst TemplateCaptureImage = () => createCaptureIamge();\\nexport const CaptureImage = TemplateCaptureImage.bind({});\\n\";\n    // @ts-ignore\n    var __LOCATIONS_MAP__ = {\"Defatult\":{\"startLoc\":{\"col\":24,\"line\":24},\"endLoc\":{\"col\":45,\"line\":24},\"startBody\":{\"col\":24,\"line\":24},\"endBody\":{\"col\":45,\"line\":24}},\"AppendDatas\":{\"startLoc\":{\"col\":28,\"line\":27},\"endLoc\":{\"col\":53,\"line\":27},\"startBody\":{\"col\":28,\"line\":27},\"endBody\":{\"col\":53,\"line\":27}},\"Resize\":{\"startLoc\":{\"col\":23,\"line\":30},\"endLoc\":{\"col\":46,\"line\":30},\"startBody\":{\"col\":23,\"line\":30},\"endBody\":{\"col\":46,\"line\":30}},\"SetAxis\":{\"startLoc\":{\"col\":24,\"line\":33},\"endLoc\":{\"col\":45,\"line\":33},\"startBody\":{\"col\":24,\"line\":33},\"endBody\":{\"col\":45,\"line\":33}},\"CaptureImage\":{\"startLoc\":{\"col\":29,\"line\":36},\"endLoc\":{\"col\":55,\"line\":36},\"startBody\":{\"col\":29,\"line\":36},\"endBody\":{\"col\":55,\"line\":36}}};\n    \nimport { createAppendDatas } from './templates/createAppendDatas';\nimport { createCaptureIamge } from './templates/createCaptureImage';\nimport { createDefault } from './templates/createDefault';\nimport { createResizable } from './templates/createResizable';\nimport { createSetAxis } from './templates/createSetAxis';\n\n// More on default export: https://storybook.js.org/docs/html/writing-stories/introduction#default-export\nexport default {\n  title: 'ScatterChart',\n  // More on argTypes: https://storybook.js.org/docs/html/api/argtypes\n  argTypes: {\n    // backgroundColor: { control: 'color' },\n    // label: { control: 'text' },\n    // onClick: { action: 'onClick' },\n    // primary: { control: 'boolean' },\n    // size: {\n    //   control: { type: 'select' },\n    //   options: ['small', 'medium', 'large'],\n    // },\n  },\n};\n\n// More on component templates: https://storybook.js.org/docs/html/writing-stories/introduction#using-args\nconst TemplateDefault = () => createDefault();\nexport const Defatult = TemplateDefault.bind({});;\n\nconst TemplateAppendDatas = () => createAppendDatas();\nexport const AppendDatas = TemplateAppendDatas.bind({});;\n\nconst TemplateResize = () => createResizable();\nexport const Resize = TemplateResize.bind({});;\n\nconst TemplateSetAxis = () => createSetAxis();\nexport const SetAxis = TemplateSetAxis.bind({});;\n\nconst TemplateCaptureImage = () => createCaptureIamge();\nexport const CaptureImage = TemplateCaptureImage.bind({});\n\n\n\nDefatult.parameters = { storySource: { source: \"() => createDefault()\" }, ...Defatult.parameters };\nAppendDatas.parameters = { storySource: { source: \"() => createAppendDatas()\" }, ...AppendDatas.parameters };\nResize.parameters = { storySource: { source: \"() => createResizable()\" }, ...Resize.parameters };\nSetAxis.parameters = { storySource: { source: \"() => createSetAxis()\" }, ...SetAxis.parameters };\nCaptureImage.parameters = { storySource: { source: \"() => createCaptureIamge()\" }, ...CaptureImage.parameters };","import { DataOption, LegendOption, PointOption } from \"../types\";\nimport { AXIS_DEFAULT_TICK_COUNT, POINT_RADIUS } from \"./ui\";\n\nexport const AXIS_DEFAULT_FORMAT = ((value: number) => value);\n\nexport const defaultOption = {};\n\nexport const defaultDataOption: DataOption[] = []\n\nexport const defaultLegendOption: LegendOption = {\n  formatLabel: (label) => label,\n  formatValue: (value) => value,\n}\n\nexport const defaultAxisOption = {\n  x: {\n    min: 0,\n    max: 1,\n    tick: {\n      count: AXIS_DEFAULT_TICK_COUNT,\n      format: AXIS_DEFAULT_FORMAT,\n    }\n  },\n  y: {\n    min: 0,\n    max: 1, \n    tick: {\n      count: AXIS_DEFAULT_TICK_COUNT,\n      format: AXIS_DEFAULT_FORMAT,\n    }\n  }\n}\n\nexport const defaultPointOption: PointOption = {\n  radius: POINT_RADIUS,\n}","export const SCATTER_CHART_IDENTIFIER = '__scatter_chart__';\nexport const PIXEL_RATIO = window && window.devicePixelRatio || 1;\n\n// container \nexport const CONTAINER_WIDTH = 518;\nexport const CONTAINER_HEIGHT = 320;\nexport const CONTAINER_PADDING = {\n  top: 15,\n  bottom: 20,\n  left: 0,\n  right: 0,\n};\n\n// axis\nexport const AXIS_INNER_PADDING = 5;\nexport const AXIS_TICK_LENGTH = 4;\nexport const AXIS_DEFAULT_TICK_COUNT = 5;\n\n// tick text\nexport const TEXT_MARGIN_TOP = 1;\nexport const TEXT_MARGIN_BOTTOM = 1;\nexport const TEXT_MARGIN_LEFT = 2;\nexport const TEXT_MARGIN_RIGHT= 2;\n\n// point\nexport const POINT_RADIUS= 3;\n\n// layer\nexport const LAYER_DEFAULT_PRIORITY = 99;","import { ScatterChart } from \"../../ui\";\nimport { newScatterChart } from \"./createDefault\";\nimport data2 from '../mock/data2.json';\nimport data3 from '../mock/data3.json';\nimport data4 from '../mock/data4.json';\nimport data5 from '../mock/data5.json';\n\nexport const createAppendDatas = () => {\n  const wrapper = document.createElement('div');\n  const datas = [data2, data3, data4, data5];\n  setTimeout(() => {\n    const SC = newScatterChart(wrapper);\n    SC.setAxisOption({x: {min: 1669103462000, max: 1669103762000}});\n\n    const btn2 = document.createElement('button');\n    const btn3 = document.createElement('button');\n    const btn4 = document.createElement('button');\n    const btn5 = document.createElement('button');\n\n    [btn2, btn3, btn4, btn5].forEach((btnElement, i) => {\n      btnElement.innerText = `append data${i + 1}` \n      btnElement.addEventListener('click', () => {\n        SC.render(datas[i].data, {append: true});\n        btnElement.disabled = true;\n      })\n      wrapper.append(btnElement);\n    })\n  }, 500);\n  return wrapper;\n}\n","import { newScatterChart } from \"./createDefault\";\n\nexport const createCaptureIamge = () => {\n  const wrapper = document.createElement('div');\n  const btnElement = document.createElement('button');\n  btnElement.innerText = 'Capture Image';\n  \n  setTimeout(() => {\n    \n    const SC = newScatterChart(wrapper);\n    wrapper.append(btnElement);\n\n    btnElement.addEventListener('click', async () => {\n      \n      const image = await SC.toBase64Image();\n\n      const downloadElement = document.createElement('a');\n      downloadElement.setAttribute(\"href\", image);\n      downloadElement.setAttribute('download', `${1}.png`);\n      wrapper.appendChild(downloadElement);\n      downloadElement.click();\n      wrapper.removeChild(downloadElement);\n    });\n  }, 500);\n  return wrapper;\n}","import { ScatterChart } from \"../../ui\";\nimport data1 from '../mock/data1.json';\n\nexport const newScatterChart = (wrapper: HTMLElement) => {\n  const SC = new ScatterChart(wrapper, {\n    axis: {\n      x: {\n        min: 1669103462000,\n        max: 1669103509335,\n        tick: {\n          count: 5,\n          format: (value) => {\n            const date = new Date(value);\n            return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}:${String(date.getSeconds()).padStart(2, '0')}`;\n          }, \n        }\n      },\n      y: {\n        min: 0,\n        max: 10000,\n        tick: {\n          count: 5,\n          format: (value) => value.toLocaleString(),\n        }\n      }\n    },\n    data: [\n      {\n        type: 'success',\n        color: 'green',\n        priority: 11,\n      },\n      {\n        type: 'fail',\n        color: 'red',\n        priority: 1,\n      },\n    ],\n    legend: {\n      formatLabel: (label) => label.toUpperCase(),\n      formatValue: (value) => value.toLocaleString(),\n    },\n  });\n  SC.render(data1.data);\n  return SC\n}\n\nexport const createDefault = () => {\n  const wrapper = document.createElement('div');\n  setTimeout(() => {\n    newScatterChart(wrapper);\n  }, 500);\n  return wrapper;\n}\n","import { newScatterChart } from \"./createDefault\";\n\nexport const createResizable = () => {\n  const wrapper = document.createElement('div');\n  const btnElement1 = document.createElement('button');\n  btnElement1.innerHTML = 'resize';\n  const btnElement2 = document.createElement('button');\n  btnElement2.innerHTML = 'resize 500 by 500';\n  \n  setTimeout(() => {\n    \n    const SC = newScatterChart(wrapper);\n    wrapper.append(btnElement1);\n    wrapper.append(btnElement2);\n\n    btnElement1.addEventListener('click', () => {\n      SC.resize();\n    });\n\n    btnElement2.addEventListener('click', () => {\n      SC.resize(500, 500);\n    });\n\n  }, 500);\n  return wrapper;\n}","import { newScatterChart } from \"./createDefault\";\n\nconst getMinMaxSettingElements = (title: string, defaultMinMax = {defaultMin: 0, defaultMax: 10000}) => {\n  const wrapper = document.createElement('div')\n  const titleElement = document.createElement('span');\n  const minInputElement = document.createElement('input');\n  const maxInputElement = document.createElement('input');\n  const buttonElement = document.createElement('button');\n\n  titleElement.style.fontWeight = 'bold';\n  titleElement.innerText = title;\n  minInputElement.type = 'number';\n  minInputElement.value = `${defaultMinMax.defaultMin}`;\n  maxInputElement.type = 'number';\n  maxInputElement.value = `${defaultMinMax.defaultMax}`; \n  buttonElement.innerText = 'set Min Max';\n\n  wrapper.append(titleElement);\n  wrapper.append(' min');\n  wrapper.append(minInputElement);\n  wrapper.append(' max');\n  wrapper.append(maxInputElement);\n  wrapper.append(buttonElement);\n\n  return wrapper;\n}\n\nexport const createSetAxis = () => {\n  const wrapper = document.createElement('div');\n\n  setTimeout(() => {\n    const SC = newScatterChart(wrapper);\n    const XAxisSetter = getMinMaxSettingElements('X Axis');\n    const YAxisSetter = getMinMaxSettingElements('Y Axis', {defaultMin: 10, defaultMax: 2500});\n    \n    wrapper.append(XAxisSetter);\n    wrapper.append(YAxisSetter);\n\n    XAxisSetter.getElementsByTagName('button')[0].addEventListener('click', () => {\n      const min = XAxisSetter.getElementsByTagName('input')[0].value;\n      const max = XAxisSetter.getElementsByTagName('input')[1].value;\n      SC.setAxisOption({x:{ min: Number(min), max: Number(max) }})\n    })\n    YAxisSetter.getElementsByTagName('button')[0].addEventListener('click', () => {\n      const min = YAxisSetter.getElementsByTagName('input')[0].value;\n      const max = YAxisSetter.getElementsByTagName('input')[1].value;\n      SC.setAxisOption({y:{ min: Number(min), max: Number(max) }})\n    })\n\n  }, 500);\n  \n  return wrapper;\n}","import { AXIS_DEFAULT_FORMAT } from \"../constants/options\";\nimport { AXIS_DEFAULT_TICK_COUNT, CONTAINER_PADDING } from \"../constants/ui\";\nimport { TickOption, FormatType, Padding, AxisOption } from \"../types\";\nimport { Layer, LayerProps } from \"./Layer\";\n\nexport interface AxisProps extends LayerProps {\n  axisOption?: AxisOption;\n  padding?: Padding;\n};\n\nexport class Axis extends Layer {\n  min;\n  max;\n  padding;\n  tickOption;\n\n  constructor({\n    axisOption,\n    padding,\n    ...props\n  }: AxisProps) {\n    super(props);\n    this.min = axisOption?.min || 0;\n    this.max = axisOption?.max || 1;\n    this.padding = { ...CONTAINER_PADDING, ...padding };\n    this.tickOption = { ...{ count: AXIS_DEFAULT_TICK_COUNT, format: AXIS_DEFAULT_FORMAT }, ...axisOption?.tick }\n  }\n\n  setOptions(options: {\n    min?: number,\n    max?: number,\n    padding?: Padding,\n    tick?: TickOption,\n  }) {\n    const { min, max, padding, tick } = options;\n    this.min = min || this.min;\n    this.max = max || this.max;\n    this.padding = { ...this.padding, ...padding };\n    this.tickOption = { ...this.tickOption, ...tick }; \n    return this;\n  }\n\n  setSize(...args: Parameters<Layer['setSize']>) {\n    super.setSize(...args);\n    return this;\n  }\n}","import { AXIS_DEFAULT_TICK_COUNT, AXIS_INNER_PADDING, AXIS_TICK_LENGTH } from \"../constants/ui\";\nimport { drawLine, drawText } from \"../utils/draw\";\nimport { Axis, AxisProps } from \"./Axis\";\n\nexport interface GridAxisProps extends AxisProps {\n  xTickCount?: number;\n  yTickCount?: number;\n};\n\nexport class GridAxis extends Axis {\n  xTickCount;\n  yTickCount;\n\n  constructor({\n    xTickCount,\n    yTickCount,\n    ...props\n  }: GridAxisProps = {}) {\n    super(props);\n    this.xTickCount = xTickCount || AXIS_DEFAULT_TICK_COUNT;\n    this.yTickCount = yTickCount || AXIS_DEFAULT_TICK_COUNT;\n    this.render();\n  }\n\n  private renderXGrid() {\n    const tickCount = this.xTickCount;\n    const padding = this.padding;\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n\n    const startX = padding.left + AXIS_INNER_PADDING;\n    const startY = padding.top;\n    const endX = width - padding.right - AXIS_INNER_PADDING;\n    const endY = height - padding.bottom; \n    const wGap = (endX - startX) / (tickCount - 1);\n\n    [...Array(tickCount)].forEach((_ , i) => {\n      const x = wGap * i + startX;\n      drawLine(this.context, x, startY, x, endY + AXIS_TICK_LENGTH, { color: '#d1d1d1'});\n    })\n  }\n\n  private renderYGrid() {\n    const tickCount = this.yTickCount;\n    const padding = this.padding;\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n    \n    const startX = padding.left;\n    const startY = padding.top + AXIS_INNER_PADDING;\n    const endX = width - padding.right + AXIS_INNER_PADDING;\n    const endY = height - padding.bottom - AXIS_INNER_PADDING;\n    const hGap = (endY - startY) / (tickCount - 1);\n\n    [...Array(tickCount)].forEach((_, i) => {\n      const y = hGap * i + startY;\n      drawLine(this.context, startX - AXIS_TICK_LENGTH, y, endX, y, { color: '#d1d1d1'});\n    })\n  }\n\n  public render() {\n    this.clear();\n    this.renderXGrid();\n    this.renderYGrid();    \n  }\n  \n  public setSize(width: number, height: number){\n    super.setSize(width, height);\n    this.render();\n    return this;\n  }\n\n  public setXTickCount(tick: number) {\n    this.xTickCount = tick;\n    return this;\n  }\n\n  public setYickCount(tick: number) {\n    this.yTickCount = tick;\n    return this;\n  }\n}","import merge from \"lodash.merge\";\nimport { AXIS_INNER_PADDING, AXIS_TICK_LENGTH, CONTAINER_PADDING, TEXT_MARGIN_BOTTOM, TEXT_MARGIN_LEFT, TEXT_MARGIN_RIGHT, TEXT_MARGIN_TOP } from \"../constants/ui\";\nimport { AxisOption, FormatType, LegendOption, Padding } from \"../types\";\nimport { drawLine, drawRect, drawText } from \"../utils/draw\";\nimport { Layer } from \"./Layer\";\n\nexport interface GuideOptions {\n  width: number;\n  height: number;\n  padding: Padding;\n  ratio: {\n    x: number;\n    y: number;\n  };\n  axisOption: { x: AxisOption, y: AxisOption };\n}\n\nexport class Guide extends Layer {\n  private wrapper;\n  private padding;\n  private ratio;\n  private axisOption;\n  private isMouseDown = false;\n  private isDragging = false;\n  private dragStartX = 0;\n  private dragStartY = 0;\n  private eventHandlers: {[key: string]: Function} = {};\n\n  constructor(wrapper: HTMLElement, {\n    width, height, padding, ratio, axisOption,\n  }: GuideOptions) {\n    super({ width, height });\n    this.canvas.style.position = 'absolute';\n    this.canvas.style.zIndex = '999';\n    this.canvas.style.top = '0px';\n    this.canvas.style.left = '0px';\n    this.canvas.style.background = 'transparent';\n    this.padding = {...CONTAINER_PADDING, ...padding};\n    this.ratio = ratio;\n    this.axisOption = axisOption;\n    this.wrapper = wrapper;\n    this.wrapper.append(this.canvas);\n    this.addEventListener();\n  }\n\n  private isMouseInValidArea(x: number, y: number) {\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n    const padding = this.padding\n\n    return (\n      x >= padding.left + AXIS_INNER_PADDING &&\n      x <= width - padding.right - AXIS_INNER_PADDING && \n      y >= padding.top + AXIS_INNER_PADDING && \n      y <= height - padding.bottom - AXIS_INNER_PADDING\n    )\n  }\n\n  private addEventListener() {\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n\n    this.canvas.addEventListener('mousedown', ({ offsetX, offsetY }) => {\n      this.isMouseDown = true;\n      this.dragStartX = offsetX;\n      this.dragStartY = offsetY;\n    });\n\n    this.canvas.addEventListener('mousemove', ({ offsetX, offsetY }) => {\n      this.context.clearRect(0, 0, width, height);\n      const x = offsetX;\n      const y = offsetY;\n      if (this.isMouseInValidArea(x, y)) {\n        // vertical line\n        // drawLine(this.context, x , 0, x, height - padding.bottom + AXIS_INNER_PADDING)\n        // horizontal line\n        // drawLine(this.context, padding.left, y, width, y)\n\n        this.drawGuideText(x,y);\n      }\n      if (this.isMouseDown) {\n        this.isDragging = true;\n        drawRect(this.context, \n          this.dragStartX, this.dragStartY, offsetX - this.dragStartX, offsetY - this.dragStartY,\n          {\n            color: 'rgba(225,225,225,0.5)',\n            strokeColor: 'blue',\n          }\n        )\n      }\n    });\n\n    this.canvas.addEventListener('mouseout', event => {\n      this.isMouseDown = false;\n      this.isDragging = false;\n      this.context.clearRect(0, 0, width, height);\n    });\n\n    this.canvas.addEventListener('mouseup', event => {\n      const { offsetX, offsetY } = event;\n      this.context.clearRect(0, 0, width, height);\n      \n      if (this.isDragging) {\n        this.isMouseInValidArea(offsetX, offsetY) && this.drawGuideText(offsetX, offsetY)\n        this.eventHandlers['dragEnd']?.({ \n          x1: this.dragStartX / this.ratio.x + this.axisOption.x.min,\n          y1: this.axisOption.y.max - (this.dragStartY - this.padding.top - AXIS_INNER_PADDING) / this.ratio.y,\n          x2: this.axisOption.y.max - (offsetX - this.padding.top - AXIS_INNER_PADDING) / this.ratio.x + this.axisOption.x.min,\n          y2: this.axisOption.y.max - (offsetY - this.padding.top - AXIS_INNER_PADDING) / this.ratio.y,\n        });\n      }\n      this.isMouseDown = false;\n    });\n\n    this.canvas.addEventListener('click', event => {\n      const { offsetX, offsetY } = event;\n      if (!this.isDragging) {\n        this.eventHandlers['click']?.({ \n          x: offsetX / this.ratio.x + this.axisOption.x.min,\n          y: this.axisOption.y.max - (offsetY - this.padding.top - AXIS_INNER_PADDING) / this.ratio.y,\n        })\n      }\n      this.isDragging = false;\n    })\n  }\n\n  private removeEventListener() {\n  }\n\n  private drawGuideText(x: number, y: number) {\n    const { padding, context, canvas, ratio, axisOption } = this;\n    const height = canvas.height / this.dpr;\n    const xText = `${axisOption.x.tick?.format!((x - padding.left - AXIS_INNER_PADDING) / ratio.x + axisOption.x.min)}`;\n    const yText = `${axisOption.y.tick?.format!(Math.floor(Math.abs((height - padding.bottom - AXIS_INNER_PADDING - y) / ratio.y + axisOption.y.min)))}`;\n    \n    // x1\n    const xTextWidth = this.getTextWidth(xText) + TEXT_MARGIN_LEFT + TEXT_MARGIN_RIGHT;\n    const xTextHeight = this.getTextHeight(xText) + TEXT_MARGIN_TOP + TEXT_MARGIN_BOTTOM;\n    // y\n    const yTextWidth = this.getTextWidth(yText) + TEXT_MARGIN_LEFT + TEXT_MARGIN_RIGHT;\n    const yTextHeight = this.getTextHeight(yText) + TEXT_MARGIN_TOP + TEXT_MARGIN_BOTTOM;\n\n    // x\n    drawRect(context, x - xTextWidth / 2, height - padding.bottom + AXIS_TICK_LENGTH, xTextWidth, xTextHeight, { color: 'black' });\n    drawLine(context, padding.left - AXIS_TICK_LENGTH, y, padding.left, y);\n    drawText(context, xText, x, height - TEXT_MARGIN_BOTTOM, { color: 'white', textAlign: 'center', textBaseline: 'bottom' });\n    // y\n    drawRect(context, padding.left - AXIS_TICK_LENGTH - yTextWidth, y - yTextHeight / 2, yTextWidth, yTextHeight, { color: 'black' });\n    drawLine(context, x, height - padding.bottom, x, height - padding.bottom + AXIS_TICK_LENGTH);\n    drawText(context, yText, padding.left - AXIS_TICK_LENGTH - TEXT_MARGIN_RIGHT, y + 3, { color: 'white', textAlign: 'end' });\n    \n  }\n\n  public setOptions({ \n    width = this.canvas.width / this.dpr, \n    height = this.canvas.height / this.dpr,\n    ratio = this.ratio,\n    padding = this.padding,\n    axisOption = this.axisOption,\n  }) {\n    this.removeEventListener();\n    super.setSize(width, height);\n    this.axisOption = merge(this.axisOption, axisOption);\n    this.padding = {...CONTAINER_PADDING, ...padding};\n    this.ratio = ratio;\n    this.addEventListener();\n  }\n\n  // public setSize(width: number, height: number){\n  //   super.setSize(width, height);\n  //   this.removeEventListener();\n  //   this.addEventListener();\n  //   return this;\n  // }\n\n  // public setPadding(padding: Padding) {\n  //   this.padding = {...CONTAINER_PADDING, ...padding};\n  //   return this;\n  // }\n\n  // public setRatio(ratio: { x: number, y: number }){\n  //   this.ratio = ratio;\n  //   this.removeEventListener();\n  //   this.addEventListener();\n  //   return this;\n  // }\n\n  public updateXAxis(x: Partial<AxisOption>) {\n    this.axisOption = {...this.axisOption, ...{ x: {...this.axisOption.x, ...x}}}\n  }\n\n  public on(evetntType: string, callback: (data: any) => void) {\n    this.eventHandlers[evetntType] = callback;\n  }\n}","import { LAYER_DEFAULT_PRIORITY } from \"../constants/ui\";\nimport { Coord } from \"../types\";\nimport { getDevicePicelRatio } from \"../utils/helper\";\n\nexport interface LayerProps {\n  width?: number;\n  height?: number;\n  display?: boolean;\n  fixed?: boolean;\n  priority?: number;\n}\n\nexport class Layer {\n  private cvs: HTMLCanvasElement;\n  private ctx: CanvasRenderingContext2D;\n  private identifier: string = '';\n  private display;\n  private fixed;\n  private priorityOrder;\n  private displayPixcelRatio;\n\n  constructor({\n     width = 0,\n     height = 0,\n     display = true,\n     fixed = false,\n     priority = LAYER_DEFAULT_PRIORITY,\n  }: LayerProps = {}) {\n    this.displayPixcelRatio = getDevicePicelRatio();\n    this.display = display;\n    this.fixed = fixed;\n    this.priorityOrder = priority;\n    this.cvs = document.createElement('canvas');\n    this.ctx = this.cvs.getContext('2d')!;\n    this.cvs.style.width = `${width}px`;\n    this.cvs.style.height = `${height}px`;\n    this.cvs.width = width * this.dpr;\n    this.cvs.height = height * this.dpr;\n    this.ctx.scale(this.dpr, this.dpr);\n  }\n\n  private resetDpr() {\n    this.displayPixcelRatio = getDevicePicelRatio();\n  }\n\n  public setSize(width: number, height: number) {\n    this.clear();\n    this.resetDpr();\n    this.cvs.style.width = `${width}px`;\n    this.cvs.style.height = `${height}px`;\n    this.cvs.width = width * this.dpr;\n    this.cvs.height = height * this.dpr;\n    this.ctx.scale(this.dpr, this.dpr);\n  }\n\n  public show() {\n    this.display = true;\n  }\n\n  public hide() {\n    this.display = false;\n  }\n\n  public clear() {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n  }\n\n  get dpr() {\n    return this.displayPixcelRatio;\n  }\n\n  get priority() {\n    return this.priorityOrder;\n  }\n\n  set priority(priority: number) {\n    this.priorityOrder = priority;\n  }\n\n  get id() {\n    return this.identifier;\n  }\n\n  set id(id: string) {\n    this.identifier = id;\n  }\n\n  get isFixed() {\n    return this.fixed;\n  }\n\n  set isFixed(fixed: boolean) {\n    this.fixed = fixed;\n  }\n\n  get canvas() {\n    return this.cvs; \n  }\n\n  get context() {\n    return this.ctx;\n  }\n\n  get isDisplay() {\n    return this.display;\n  }\n\n  public swapCanvasImage() {\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n    const rightImage = this.getCroppedImage(this.ctx, { x: width, y: 0 }, { x: width * 2, y: height });\n    this.ctx.clearRect(0, 0, width, height);\n    this.ctx.putImageData(rightImage, 0, 0)\n  }\n\n  public getCroppedImage(ctx: CanvasRenderingContext2D, lCoord: Coord, rCoord: Coord) {\n    return ctx.getImageData(lCoord.x, lCoord.y, rCoord.x, rCoord.y);\n  }\n\n  public getTextWidth(text: string | number) {\n    return this.context.measureText(`${text}`).width;\n  }\n\n  public getTextHeight(text: string | number) {\n    const metrics = this.context.measureText(`${text}`);\n    let fontHeight = metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent;\n    // let actualHeight = metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent;\n    return fontHeight;\n  }\n}","import { SCATTER_CHART_IDENTIFIER } from \"../constants/ui\";\nimport { LegendOption } from \"../types\";\n\nexport type LegendProps = { \n  types: string[], \n  legendOptions: LegendOption, \n  dataColorMap: {[key: string]: string},\n  width?: number;\n}\nexport class Legend {\n  static LEGEND_CLASS = `${SCATTER_CHART_IDENTIFIER}legend`;\n  static LEGEND_CONTAINER_CLASS = `${Legend.LEGEND_CLASS}_container`;\n  static MARK_CLASS = `${Legend.LEGEND_CLASS}_mark`;\n  static COUNT_CLASS = `${Legend.LEGEND_CLASS}_count`;\n  private rootWrapper;\n  private types;\n  private options;\n  private dataColorMap;\n  private containerElement: HTMLElement;\n  private legendElements: {[key: string]: HTMLDivElement} = {} \n  \n  constructor(rootWrapper: HTMLElement, { types, legendOptions, dataColorMap, width }: LegendProps) {\n    this.rootWrapper = rootWrapper;\n    this.types = types;\n    this.options = legendOptions;\n    this.dataColorMap = dataColorMap;\n    this.containerElement = document.createElement('div');\n    this.containerElement.className = Legend.LEGEND_CONTAINER_CLASS;\n    this.setSize(width);\n  }\n\n  get container() {\n    return this.containerElement;\n  }\n  \n  public setSize(width?: number) {\n    this.containerElement.style.width = `${width}px` || `${this.rootWrapper.clientWidth}px`;\n  }\n\n  public addEvents(callback?: ({ type, checked }: { type: string, checked: boolean}) => void) {\n    this.containerElement.addEventListener('click', (event) => {\n      const isInputNode = event.target.nodeName === 'INPUT';\n      const wrapper = event.target.closest('div');\n      const checkbox = wrapper.querySelector('input');\n\n      if (isInputNode) {\n        callback?.({ type: wrapper.dataset.name, checked: checkbox.checked });\n      }\n    });\n    return this;\n  }\n\n  public render() {\n    const options = this.options;\n    const dataTypes = this.types;\n\n    dataTypes.forEach(type => {\n      // wrapper div\n      const legendWrapper = document.createElement('div');\n      legendWrapper.dataset.name = type;\n      legendWrapper.className = `${Legend.LEGEND_CLASS} ${type}`;\n\n      // mark\n      const markElement = document.createElement('span');\n      markElement.style.background = this.dataColorMap[type];\n      // const formattedLabel = options?.formatLabel?.(type) || type;\n      markElement.className = Legend.MARK_CLASS;\n\n      // count span\n      const countElement = document.createElement('span');\n      countElement.className = Legend.COUNT_CLASS;\n\n      // label\n      const labelElement = document.createElement('label');\n      const formattedLabel = options?.formatLabel?.(type) || type;\n      labelElement.htmlFor = `${Legend.LEGEND_CLASS}_${type}_input`;\n      labelElement.append(`${formattedLabel}`, countElement);\n\n\n      // input\n      const inputElement = document.createElement('input');\n      inputElement.id = `${Legend.LEGEND_CLASS}_${type}_input`;\n      inputElement.type = 'checkbox';\n      inputElement.checked = true;\n\n      this.legendElements[type] = legendWrapper;\n\n      legendWrapper.append(markElement, labelElement, inputElement);\n      this.containerElement.append(legendWrapper);\n    })\n    this.rootWrapper.append(this.containerElement);\n  }\n\n  public setLegendCount(type: string, value: number) {\n    const legendElement = this.legendElements[type];\n    const countElement = legendElement.getElementsByClassName(Legend.COUNT_CLASS)[0];\n\n    countElement.innerHTML = `${this.options.formatValue?.(value)}`;\n  }\n}","import merge from 'lodash.merge';\nimport html2canvas from 'html2canvas';\n\nimport { AxisOption, DataOption, LegendOption, Padding, ScatterDataType } from \"../types\";\nimport { Layer } from \"./Layer\";\nimport { Viewport } from \"./Viewport\";\nimport { drawCircle, drawRect, drawText } from \"../utils/draw\";\nimport { YAxis } from \"./YAxis\";\nimport { XAxis } from \"./XAxis\";\nimport { AXIS_INNER_PADDING, AXIS_TICK_LENGTH, CONTAINER_HEIGHT, CONTAINER_PADDING, CONTAINER_WIDTH, LAYER_DEFAULT_PRIORITY, SCATTER_CHART_IDENTIFIER, TEXT_MARGIN_BOTTOM, TEXT_MARGIN_LEFT, TEXT_MARGIN_RIGHT, TEXT_MARGIN_TOP } from \"../constants/ui\";\nimport { GridAxis } from \"./GridAxis\";\nimport { Legend } from \"./Legend\";\nimport { Guide } from \"./Guide\";\nimport { defaultAxisOption, defaultDataOption, defaultLegendOption } from \"../constants/options\";\nimport { getLongestTextWidth, getTickTexts } from '../utils/helper';\n\nexport interface ScatterChartOption {\n  axis: { x: AxisOption, y: AxisOption };\n  data: DataOption[];\n  legend?: LegendOption;\n}\n\nexport class ScatterChart {\n  static SCATTER_CHART_CONTAINER_CLASS = `${SCATTER_CHART_IDENTIFIER}container`;\n  private wrapper;\n  private canvasWrapper;\n  private options!: ScatterChartOption;\n  private xAxis!: XAxis;\n  private yAxis!: YAxis;\n  private gridAxis!: GridAxis;\n  private legend!: Legend;\n  private dataColorMap!: { [key: string]: string };\n  private viewport!: Viewport;\n  private guide!: Guide;\n  private dataLayers: { [key: string]: Layer } = {};\n  private data: ScatterDataType[] = [];\n  private datas: {[key: string]: number[]} = {};\n  private xRatio = 1;\n  private yRatio = 1;\n  private coordX = 0;\n  private coordY = 0;\n  private realtimeAxisMinX = 0;\n  private realtimeAxisMaxX = 0;\n  private width = 0;\n  private height = 0;\n  private padding = CONTAINER_PADDING;\n  private t0: number = 0;\n  private reqAnimation = 0;\n\n  constructor(wrapper: HTMLElement, options: ScatterChartOption) {\n    this.wrapper = wrapper;\n    this.canvasWrapper = document.createElement('div');\n    this.canvasWrapper.className = ScatterChart.SCATTER_CHART_CONTAINER_CLASS;\n    this.canvasWrapper.style.position = 'relative';\n    this.wrapper.append(this.canvasWrapper);\n\n    this.setOptions(options);\n    this.setWidthAndHeight();\n    this.setViewPort();\n    this.setPadding();\n    this.setRatio();\n    this.setAxis();\n    this.setGuide();\n    this.setLayers();\n    this.setLegends();\n\n    this.shoot();\n    this.animate = this.animate.bind(this);\n  }\n\n  private setOptions(options: ScatterChartOption) {\n    this.options = {\n      // TODO deep copy\n      axis: merge(defaultAxisOption, options.axis),\n      data: [...defaultDataOption, ...options.data],\n      legend: merge(defaultLegendOption, options.legend),\n    };\n\n    this.dataColorMap = this.options.data.reduce((prev, curr) => {\n      return {\n        [curr.type]: curr.color,\n        ...prev,\n      }\n    }, {});\n  }\n\n  private setWidthAndHeight() {\n    this.width = this.canvasWrapper.clientWidth || CONTAINER_WIDTH;\n    this.height = this.canvasWrapper.clientHeight || CONTAINER_HEIGHT;\n  }\n\n  private setPadding() {\n    const xformatter = this.options.axis.x.tick?.format;\n    const xTicks = getTickTexts(this.options.axis.x);\n    const yTicks = getTickTexts(this.options.axis.y);\n    const maxXTickTextWidth = getLongestTextWidth(xTicks, (t) => this.viewport.viewLayer.getTextWidth(t));\n    const maxYTickTextWidth = getLongestTextWidth(yTicks, (t) => this.viewport.viewLayer.getTextWidth(t));\n    const formattedXSample = xformatter ? xformatter(this.options.axis.x.max) : this.options.axis.x.max;\n\n    this.padding.left = (maxXTickTextWidth / 2 > maxYTickTextWidth ? maxXTickTextWidth / 2 : maxYTickTextWidth) + TEXT_MARGIN_LEFT + TEXT_MARGIN_RIGHT + AXIS_TICK_LENGTH;\n    this.padding.right = maxXTickTextWidth / 2 + TEXT_MARGIN_RIGHT;\n    this.padding.bottom = this.viewport.viewLayer.getTextHeight(formattedXSample) + TEXT_MARGIN_TOP + TEXT_MARGIN_BOTTOM + AXIS_TICK_LENGTH;\n  }\n\n  private setViewPort() {\n    this.viewport = new Viewport(\n      this.canvasWrapper,\n      { width: this.width, height: this.height }\n    );\n  }\n\n  private setGuide() {\n    this.guide = new Guide(\n      this.canvasWrapper,\n      { \n        width: this.width, \n        height: this.height, \n        padding: this.padding, \n        axisOption: this.options.axis,\n        ratio: {\n          x: this.xRatio,\n          y: this.yRatio,\n        }\n      }\n    )\n  }\n\n  private setAxis() {\n    const options = this.options;\n\n    this.yAxis = new YAxis({\n      axisOption: options.axis.y,\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: -2,\n      fixed: true,\n    });\n\n    this.xAxis = new XAxis({\n      axisOption: options.axis.x,\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: -1,\n    });\n\n    this.gridAxis = new GridAxis({\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: 9999,\n      xTickCount: options.axis.x.tick?.count,\n      yTickCount: options.axis.y.tick?.count,\n    })\n\n    this.viewport.addLayer(this.yAxis);\n    this.viewport.addLayer(this.xAxis);\n    this.viewport.addLayer(this.gridAxis);\n  }\n\n  private setLayers() {\n    const width = this.viewport.styleWidth;\n    const height = this.viewport.styleHeight;\n    const dataOptions = this.options.data;\n\n    dataOptions.forEach(({ type, priority = LAYER_DEFAULT_PRIORITY }) => {\n      this.setLayer(type, width, height, priority);\n    })\n  }\n\n  private setLayer(legend: string, width: number, height: number, priority: number) {\n    const layer = new Layer({ width, height });\n    layer.id = legend;\n    layer.priority = priority;\n    this.dataLayers[legend] = layer;\n    this.viewport.addLayer(layer);\n  }\n\n  private setLegends() {\n    this.legend = new Legend(this.wrapper, { \n      types: Object.keys(this.dataLayers), \n      dataColorMap: this.dataColorMap,\n      legendOptions: this.options?.legend!\n    });\n    this.legend.addEvents(({ type, checked }) => {\n      if (type) {\n        if (checked) {\n          this.viewport.showLayer(type);\n        } else {\n          this.viewport.hideLayer(type);\n        }\n      }\n      this.shoot();\n    }).render();\n  }\n\n  private setRatio() {\n    const axis = this.options?.axis;\n    const padding = this.padding;\n    const width = this.viewport.canvas.width / this.viewport.viewLayer.dpr;\n    const height = this.viewport.canvas.height / this.viewport.viewLayer.dpr;\n    const minX = axis.x.min;\n    const maxX = axis.x.max;\n    const minY = axis.y.min;\n    const maxY = axis.y.max;\n\n    this.xRatio = (width - padding.left - padding.right - AXIS_INNER_PADDING * 2) / (maxX - minX);\n    this.yRatio = (height - padding.bottom - padding.top - AXIS_INNER_PADDING * 2) / (maxY - minY);\n  }\n\n  private shoot() {\n    this.viewport.clear();\n    drawRect(this.viewport.context, 0, 0, this.width, this.height);\n    this.viewport.render(this.coordX, this.coordY);\n    \n    Object.keys(this.datas).forEach(key => {\n      this.legend.setLegendCount(key, this.datas[key].length);\n    })\n  }\n\n  private animate(duration: number, now: number) {\n    this.shoot();\n    if (!this.t0) this.t0 = now;\n    const dt = now - this.t0;\n    const pixcelPerFrame = (this.viewport.styleWidth - this.padding.left - this.padding.right - AXIS_INNER_PADDING * 2) / duration * dt;\n    const pixcelPerSecond = pixcelPerFrame * 60;\n\n    this.t0 = now;\n    this.coordX = this.coordX - pixcelPerFrame;\n\n    //   \n    if (Math.abs(Math.floor(this.coordX)) % (Math.floor(pixcelPerSecond / 5)) === 0) {\n      const x = Math.abs(this.coordX) / this.xRatio;\n      Object.keys(this.datas).forEach(key => {\n        this.datas[key] = this.datas[key].filter(d => d > x);\n      })\n\n      this.guide.updateXAxis({ min: x + this.xAxis.min});\n    }\n\n    if (this.coordX > -(this.viewport.styleWidth - this.padding.left - this.padding.right - AXIS_INNER_PADDING * 2)) {\n      this.reqAnimation = requestAnimationFrame((t) => this.animate(duration, t))\n    } else {\n      // swap\n      const nextAxisMinX = this.realtimeAxisMinX + (this.realtimeAxisMaxX - this.realtimeAxisMinX) / 2;\n      const nextAxisMaxX = this.realtimeAxisMaxX + (this.realtimeAxisMaxX - this.realtimeAxisMinX) / 2;\n      this.realtimeAxisMinX = nextAxisMinX;\n      this.realtimeAxisMaxX = nextAxisMaxX;\n      this.coordX = 0;\n\n      this.xAxis\n        .setMinMax(this.realtimeAxisMinX, this.realtimeAxisMaxX)\n        .render();\n      Object.values(this.dataLayers).filter(layer => !layer.isFixed).forEach(layer =>  layer.swapCanvasImage());\n      this.reqAnimation = requestAnimationFrame((t) => this.animate(duration, t))\n    }\n  }\n\n  public render(data: ScatterDataType[], { append = false } = {}) {\n    const { styleWidth, styleHeight } = this.viewport;\n    const { x: xAxisOptoin, y: yAxisOption } = this.options.axis\n    const padding = this.padding;\n\n    if (append) {\n      this.data = [...this.data, ...data];\n    } else {\n      this.data = data;\n      this.datas = {};\n      Object.values(this.dataLayers).forEach(layer => layer.clear());\n    }\n\n    data.forEach(({ x, y, type, hidden }) => {\n      const legend = type ? type : 'unknown';\n\n      if (!this.dataLayers[legend]) {\n        this.setLayer(legend, styleWidth, styleHeight, LAYER_DEFAULT_PRIORITY);\n      }\n      \n      if (this.datas[legend]) {\n        this.datas[legend].push(x);\n      } else {\n        this.datas[legend] = [x];\n      }\n\n      !hidden && drawCircle(\n        this.dataLayers[legend].context,\n        this.xRatio * (x - this.xAxis.min) + padding.left + AXIS_INNER_PADDING,\n        this.viewport.canvas.height / this.viewport.viewLayer.dpr - this.yRatio * y - padding.bottom - AXIS_INNER_PADDING,\n        {\n          fillColor: this.dataColorMap[legend],\n        }\n      );\n    });\n    this.shoot();\n  }\n\n  public on(evetntType: string, callback: (data: any) => void) {\n    this.guide.on(evetntType, callback);\n  }\n\n  public resize(width?: number, height?: number) {\n    const w = width || this.canvasWrapper.clientWidth;\n    const h = height || this.canvasWrapper.clientHeight;\n\n    this.viewport.setSize(w, h);\n    this.setRatio();\n    this.xAxis.setSize(w, h);\n    this.yAxis.setSize(w, h);\n    this.gridAxis.setSize(w, h);\n    this.guide.setOptions({\n      width: w,\n      height: h,\n      ratio: { x: this.xRatio, y: this.yRatio }\n    });\n    Object.values(this.dataLayers).forEach(layer => layer.setSize(w, h));\n    this.legend.setSize(w);\n    this.render(this.data);\n  }\n\n  public setAxisOption(axisOption: {\n    x?: Partial<AxisOption>,\n    y?: Partial<AxisOption>,\n  }) {\n    this.setOptions(merge(this.options, { axis: axisOption }));\n    this.setPadding();\n    this.setRatio();\n    this.guide.setOptions({\n      padding: this.padding,\n      ratio: {x: this.xRatio, y: this.yRatio},\n    });\n    this.xAxis\n      .setOptions({\n        ...this.options.axis.x,\n        padding: this.padding,\n      })\n      .render();\n    this.yAxis\n      .setOptions({\n        ...this.options.axis.y,\n        padding: this.padding,\n      })\n      .render();\n    this.gridAxis\n      .setOptions({ padding: this.padding })\n      .render();\n    this.render(this.data);\n  }\n\n  public async toBase64Image() {\n    const layer = new Layer({ width: this.width , height: this.height});\n    const containerCanvas = await html2canvas(document.querySelector(`.${ScatterChart.SCATTER_CHART_CONTAINER_CLASS}`)!).then(canvas => canvas);\n    const legendCanvas = await html2canvas(document.querySelector(`.${Legend.LEGEND_CONTAINER_CLASS}`)!).then(canvas => canvas);\n\n    layer.setSize(containerCanvas.width, containerCanvas.height + legendCanvas.height);\n    layer.context.drawImage(containerCanvas, 0, 0);\n    layer.context.drawImage(legendCanvas, 0, containerCanvas.height);\n\n    const image = layer.canvas\n      .toDataURL(\"image/png\")\n      .replace(\"image/png\", \"image/octet-stream\");\n\n    return image;\n  }\n\n  // public startRealtime(duration: number) {\n  //   if (this.reqAnimation) return;\n  //   const axisOptions = this.options.axis;\n  //   this.xAxis\n  //     .setTickCount(axisOptions.x.tick?.count! * 2 - 1)\n  //     .setSize(this.width * 2 - this.padding.left - AXIS_INNER_PADDING * 2 - this.padding.right, this.height)\n  //     .setMinMax(axisOptions.x.min, axisOptions.x.max * 2 - axisOptions.x.min)\n  //     .render();\n  //   this.realtimeAxisMinX = axisOptions.x.min;\n  //   this.realtimeAxisMaxX = axisOptions.x.max * 2 - axisOptions.x.min;\n\n  //   this.gridAxis\n  //     .setXTickCount(axisOptions.x.tick?.count! * 2 - 1)\n  //     .setSize(this.width * 2 - this.padding.left - AXIS_INNER_PADDING * 2 - this.padding.right, this.height)\n  //     .render();\n  //   this.animate(duration, this.t0);\n  // }\n\n  // public stopRealtime() {\n  //   cancelAnimationFrame(this.reqAnimation);\n  //   const axisOptions = this.options.axis;\n  //   this.reqAnimation = 0;\n  //   this.coordX = 0;\n  //   this.t0 = 0;\n\n  //   this.xAxis\n  //     .setTickCount(axisOptions.x.tick?.count!)\n  //     .setSize(this.width, this.height)\n  //     .setMinMax(axisOptions.x.min, axisOptions.x.max)\n  //     .render();\n  //   this.realtimeAxisMinX = axisOptions.x.min;\n  //   this.realtimeAxisMaxX = axisOptions.x.max;\n\n  //   this.guide.updateXAxis({ min: axisOptions.x.min });\n\n  //   this.gridAxis\n  //     .setXTickCount(axisOptions.x.tick?.count!)\n  //     .setSize(this.width, this.height)\n  //     .render();\n  //   this.shoot();\n  // }\n}\n","import { drawRect } from \"../utils/draw\";\nimport { Layer } from \"./Layer\";\n\nexport interface ViewportOption {\n  width: number;\n  height: number;\n}\n\nexport class Viewport {\n  private view: Layer;\n  private layers: Layer[];\n  private width: number;\n  private height: number;\n  \n  constructor(wrapper: HTMLElement, {\n    width = 0,\n    height = 0,\n  }) {\n    this.width = width;\n    this.height = height;\n    this.layers = [];\n    this.view = new Layer({\n      width, \n      height,\n    });\n    this.view.canvas.style.display = 'block';\n    wrapper.append(this.view.canvas);\n  }\n\n  get viewLayer() {\n    return this.view;\n  }\n\n  get canvas() {\n    return this.view.canvas;\n  }\n\n  get context() {\n    return this.view.context;\n  }\n\n  get styleWidth() {\n    return this.width;\n  }\n\n  get styleHeight() {\n    return this.height;  \n  }\n\n  public render(x: number, y: number) {\n    this.layers.forEach(layer => {\n      const layerCanvas = layer.canvas;\n      const dpr = layer.dpr;\n      \n      if (layer.isDisplay) {\n        if (layer.isFixed) {\n          this.view.context.drawImage(\n            layerCanvas, \n            0, 0, layerCanvas.width, layerCanvas.height, \n            0, 0, layerCanvas.width / dpr, layerCanvas.height / dpr\n          );\n        } else {\n          this.view.context.drawImage(\n            layerCanvas, \n            -x * dpr, y * dpr, layerCanvas.width, layerCanvas.height,\n            0, y, layerCanvas.width / dpr, layerCanvas.height / dpr\n          );\n        }\n      } \n    })\n  }\n\n  public hideLayer(id: string) {\n    this.layers.filter(layer => layer.id === id)[0].hide();\n  }\n\n  public showLayer(id: string) {\n    this.layers.filter(layer => layer.id === id)[0].show();\n  }\n\n  public addLayer(layer: Layer | Layer[]) {\n    if (Array.isArray(layer)) {\n      this.layers = [\n        ...this.layers,\n        ...layer,\n      ];\n    } else {\n      this.layers.push(layer);\n    }\n    this.layers.sort((a, b) => {\n      if (a.priority > b.priority) {\n        return -1;\n      } else \n        return 1;\n    })\n    \n    return this;\n  }\n\n  public setSize(width: number, height: number) {\n    this.view.setSize(width, height);\n    return this;\n  } \n\n  public setLayersSize(width: number, height: number) {\n    this.layers.forEach(layer => {\n      layer.setSize(width, height);\n    });\n    return this;\n  }\n\n  public clear() {\n    this.view.context.clearRect(0, 0, this.view.canvas.width, this.view.canvas.height);\n  }\n}","import { AXIS_INNER_PADDING, AXIS_TICK_LENGTH, TEXT_MARGIN_BOTTOM } from \"../constants/ui\";\nimport { drawLine, drawText } from \"../utils/draw\";\nimport { Axis, AxisProps } from \"./Axis\";\n\nexport interface XAxisProps extends AxisProps {};\n\nexport class XAxis extends Axis {\n  constructor({\n    ...props\n  }: XAxisProps = {}) {\n    super(props);\n    this.render();\n  }\n\n  public setSize(width: number, height: number){\n    super.setSize(width, height);\n    this.render();\n    return this;\n  }\n\n  public render() {\n    this.clear();\n    const { format, count } = this.tickOption;\n    const padding = this.padding;\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n\n    const startX = padding.left + AXIS_INNER_PADDING;\n    const endX = width - padding.right - AXIS_INNER_PADDING;\n    const endY = height - padding.bottom; \n    const wGap = (endX - startX) / (count - 1);\n    const xTickGap = (this.max - this.min) / (count - 1);\n\n    [...Array(count)].forEach((_ , i) => {\n      const x = wGap * i + startX;\n      const label = format(xTickGap * i + this.min)\n      drawText(this.context, `${label}`, x, height - TEXT_MARGIN_BOTTOM, { textAlign: 'center', textBaseline: 'bottom' });\n      drawLine(this.context, x, endY, x, endY + AXIS_TICK_LENGTH);\n    })\n    drawLine(this.context, startX - AXIS_INNER_PADDING, endY, endX  + AXIS_INNER_PADDING, endY);\n  }\n}","import { AXIS_INNER_PADDING, AXIS_TICK_LENGTH, TEXT_MARGIN_LEFT, TEXT_MARGIN_RIGHT } from \"../constants/ui\";\nimport { drawLine, drawRect, drawText } from \"../utils/draw\";\nimport { Axis, AxisProps } from \"./Axis\";\n\nexport interface YAxisProps extends AxisProps {};\n\nexport class YAxis extends Axis {\n  constructor({\n    ...props\n  }: YAxisProps = {}) {\n    super(props);\n    this.render();\n  }\n\n  public setSize(width: number, height: number){\n    super.setSize(width, height);\n    this.render();\n    return this;\n  }\n\n  public render() {\n    this.clear();\n    const { count, format } = this.tickOption;\n    const padding = this.padding;\n    const width = this.canvas.width / this.dpr;\n    const height = this.canvas.height / this.dpr;\n    \n    const startX = padding.left;\n    const startY = padding.top + AXIS_INNER_PADDING;\n    const endY = height - padding.bottom - AXIS_INNER_PADDING;\n    const hGap = (endY - startY) / (count - 1);\n    const yTickGap = (this.max - this.min) / (count - 1);\n\n    drawRect(this.context, 0, 0, padding.left, endY + AXIS_INNER_PADDING + AXIS_TICK_LENGTH);\n    drawRect(this.context, width - padding.right, 0, width, endY + AXIS_INNER_PADDING + AXIS_TICK_LENGTH);\n    drawRect(this.context, 0, 0, width, padding.top);\n    \n    [...Array(count)].forEach((_, i) => {\n      const y = hGap * i + startY;\n      const label = format(yTickGap * (count - 1 - i) + this.min);\n      \n      drawLine(this.context, startX - AXIS_TICK_LENGTH, y, startX, y);\n      drawText(this.context, `${label}`, startX - TEXT_MARGIN_RIGHT - AXIS_TICK_LENGTH, y + 3, { textAlign: 'end' });\n    })\n    drawLine(this.context, startX, startY - AXIS_INNER_PADDING, startX, endY + AXIS_INNER_PADDING);\n  }\n}","import { defaultPointOption } from \"../constants/options\";\n\nexport const drawCircle = (\n  ctx: CanvasRenderingContext2D, \n  x: number, \n  y: number, \n  { \n    radius = defaultPointOption.radius!,\n    fillColor = 'black',\n  }: { \n    radius?: number,\n    fillColor?: string,\n  } = {}\n) => {\n  ctx.beginPath()\n  ctx.arc(x, y, radius, 0, radius * Math.PI);\n  ctx.fillStyle = fillColor;\n  ctx.fill();\n}\n\nexport const drawLine = (\n  ctx: CanvasRenderingContext2D,\n  fromX: number,\n  fromY: number,\n  toX: number,\n  toY: number,\n  { \n    color = 'black', \n  }: { \n    color?: string \n  } = {}\n) => {\n  ctx.beginPath();\n  ctx.moveTo(fromX, fromY);\n  ctx.lineTo(toX, toY);\n  ctx.strokeStyle = color;\n  ctx.stroke();\n}\n\nexport const drawText = (\n  ctx: CanvasRenderingContext2D,\n  text: string,\n  x: number,\n  y: number,\n  {\n    color = 'black',\n    textAlign = 'center',\n    textBaseline = 'alphabetic',\n  }: { \n    color?: string,\n    textAlign?: CanvasTextAlign,\n    textBaseline?: CanvasTextBaseline,\n  } = {}\n) => {\n  ctx.textAlign = textAlign; \n  ctx.textBaseline = textBaseline; \n  ctx.fillStyle = color;\n  ctx.fillText(text, x, y);\n}\n\nexport const drawRect = (\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  { \n    color = 'white',\n    strokeColor,\n  }: {\n    color?: string,\n    strokeColor?: string,\n  } = {}\n) => {\n  ctx.fillStyle = color;\n  ctx.fillRect(x, y, width, height);\n  if (strokeColor) {\n    ctx.strokeStyle = strokeColor;\n    ctx.strokeRect(x, y, width, height);        \n  }\n}","import { AXIS_DEFAULT_TICK_COUNT } from \"../constants/ui\";\nimport { AxisOption } from \"../types\";\nimport { Layer } from \"../ui/Layer\";\n\nexport const getDevicePicelRatio = () => {\n  const dpr = window?.devicePixelRatio || 2;\n\n  return dpr;\n}\n\nexport const getTickTexts = ({ min, max, tick }: AxisOption) => {\n  const tickCount = tick?.count || AXIS_DEFAULT_TICK_COUNT;\n  const gap = (max - min) / (tickCount - 1);\n  return [...Array(tickCount)].map((_, i) => {\n    const value = min + gap * i;\n    const result = tick?.format?.(value) || value;\n\n    return `${result}`;\n  });\n}\n\nexport const getLongestTextWidth = (texts: string[], measurer: (t: string) => number) => {\n  const text = texts.reduce((prev: string, curr: string) => {\n    const prevWidth = measurer(prev);\n    const currWidth = measurer(curr);\n\n    return prevWidth > currWidth ? prev : curr;\n  }, '0');\n\n  return measurer(text);\n}\n","// Imports\nimport ___CSS_LOADER_API_SOURCEMAP_IMPORT___ from \"../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/cssWithMappingToString.js\";\nimport ___CSS_LOADER_API_IMPORT___ from \"../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/runtime/api.js\";\nvar ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(___CSS_LOADER_API_SOURCEMAP_IMPORT___);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \".__scatter_chart__legend_container {\\n  display: flex;\\n  padding-top: 10px;\\n  padding-bottom: 5px;\\n  justify-content: space-around;\\n}\\n.__scatter_chart__legend {\\n  display: flex;\\n  gap: 4px;\\n}\\n.__scatter_chart__legend label {\\n  font-size: 0.85rem;\\n}\\n.__scatter_chart__legend_count {\\n  font-size: 1rem;\\n  margin-left: 4px;\\n}\\n.__scatter_chart__legend_mark {\\n  height: 1rem;\\n  width: 1rem;\\n  background-color: #bbb;\\n  border-radius: 50%;\\n  display: inline-block;\\n  margin-right: 3px;\\n}\", \"\",{\"version\":3,\"sources\":[\"webpack://./src/style/index.css\"],\"names\":[],\"mappings\":\"AAAA;EACE,aAAa;EACb,iBAAiB;EACjB,mBAAmB;EACnB,6BAA6B;AAC/B;AACA;EACE,aAAa;EACb,QAAQ;AACV;AACA;EACE,kBAAkB;AACpB;AACA;EACE,eAAe;EACf,gBAAgB;AAClB;AACA;EACE,YAAY;EACZ,WAAW;EACX,sBAAsB;EACtB,kBAAkB;EAClB,qBAAqB;EACrB,iBAAiB;AACnB\",\"sourcesContent\":[\".__scatter_chart__legend_container {\\n  display: flex;\\n  padding-top: 10px;\\n  padding-bottom: 5px;\\n  justify-content: space-around;\\n}\\n.__scatter_chart__legend {\\n  display: flex;\\n  gap: 4px;\\n}\\n.__scatter_chart__legend label {\\n  font-size: 0.85rem;\\n}\\n.__scatter_chart__legend_count {\\n  font-size: 1rem;\\n  margin-left: 4px;\\n}\\n.__scatter_chart__legend_mark {\\n  height: 1rem;\\n  width: 1rem;\\n  background-color: #bbb;\\n  border-radius: 50%;\\n  display: inline-block;\\n  margin-right: 3px;\\n}\"],\"sourceRoot\":\"\"}]);\n// Exports\nexport default ___CSS_LOADER_EXPORT___;\n","import api from \"!../../node_modules/@storybook/builder-webpack5/node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\";\n            import content from \"!!../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[8].use[1]!./index.css\";\n\nvar options = {};\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (module.hot) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n  if (!a && b || a && !b) {\n    return false;\n  }\n\n  var p;\n\n  for (p in a) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (a[p] !== b[p]) {\n      return false;\n    }\n  }\n\n  for (p in b) {\n    if (isNamedExport && p === 'default') {\n      // eslint-disable-next-line no-continue\n      continue;\n    }\n\n    if (!a[p]) {\n      return false;\n    }\n  }\n\n  return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      \"!!../../node_modules/@storybook/builder-webpack5/node_modules/css-loader/dist/cjs.js??ruleSet[1].rules[8].use[1]!./index.css\",\n      function () {\n        if (!isEqualLocals(oldLocals, content.locals, undefined)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nexport default content.locals || {};","var map = {\n\t\"./index.stories.ts\": \"./src/stories/index.stories.ts\"\n};\n\n\nfunction webpackContext(req) {\n\tvar id = webpackContextResolve(req);\n\treturn __webpack_require__(id);\n}\nfunction webpackContextResolve(req) {\n\tif(!__webpack_require__.o(map, req)) {\n\t\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\t\te.code = 'MODULE_NOT_FOUND';\n\t\tthrow e;\n\t}\n\treturn map[req];\n}\nwebpackContext.keys = function webpackContextKeys() {\n\treturn Object.keys(map);\n};\nwebpackContext.resolve = webpackContextResolve;\nmodule.exports = webpackContext;\nwebpackContext.id = \"./src/stories sync recursive ^\\\\.(?:(?:^%7C\\\\/%7C(?:(?:(?%21(?:^%7C\\\\/)\\\\.).)*?)\\\\/)(?%21\\\\.)(?=.)[^/]*?\\\\.stories\\\\.(js%7Cjsx%7Cts%7Ctsx))$\";","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = \"./src/stories sync recursive ^\\\\.(?:(?:^%7C\\\\/%7C(?:(?:(?%21(?:^%7C\\\\/)\\\\.).)*?)\\\\/)(?%21\\\\.)(?=.)[^/]*?\\\\.stories\\\\.mdx)$\";\nmodule.exports = webpackEmptyContext;","/* (ignored) */","\"use strict\";\n\nvar _frameworkImportPath = require(\"@storybook/html\");\n\n/* eslint-disable import/no-unresolved */\n(0, _frameworkImportPath.configure)([require.context('./src/stories', true, /^\\.(?:(?:^|\\/|(?:(?:(?!(?:^|\\/)\\.).)*?)\\/)(?!\\.)(?=.)[^/]*?\\.stories\\.mdx)$/),require.context('./src/stories', true, /^\\.(?:(?:^|\\/|(?:(?:(?!(?:^|\\/)\\.).)*?)\\/)(?!\\.)(?=.)[^/]*?\\.stories\\.(js|jsx|ts|tsx))$/)], module, false);"],"names":[],"sourceRoot":""}