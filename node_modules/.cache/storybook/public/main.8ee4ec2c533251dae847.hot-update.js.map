{"version":3,"file":"main.8ee4ec2c533251dae847.hot-update.js","mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AA8BA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AARA;AACA;AACA;AACA;AAJA;AASA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAhDA;AAAA;AAAA;AAmDA;AACA;AACA;AACA;AACA;AAJA;AAOA;AAAA;;AACA;AAIA;AACA;AAhEA;AAAA;AAAA;AAmEA;AACA;AACA;AArEA;AAAA;AAAA;AAuEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAlFA;AAAA;AAAA;AAqFA;AAEA;AAAA;AAAA;AAEA;AAzFA;AAAA;AAAA;AA4FA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AALA;AAWA;AAzGA;AAAA;AAAA;AA2GA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAWA;AACA;AACA;AACA;AAjJA;AAAA;AAAA;AAmJA;;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;;AACA;AACA;AACA;AA3JA;AAAA;AAAA;AA8JA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAnKA;AAAA;AAAA;AAqKA;AAAA;;AACA;AACA;AACA;AACA;AAHA;AAKA;AAAA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AArLA;AAAA;AAAA;AAuLA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAnMA;AAAA;AAAA;AAqMA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA7MA;AAAA;AAAA;AA+MA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAnPA;AAAA;AAAA;AAqPA;;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAKA;AADA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AA5TA;AAAA;AAAA;AA+TA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AA3UA;;AAAA;AAAA","sources":["webpack://@pinpoint-fe/scatter-chart/./src/ui/ScatterChart.ts"],"sourcesContent":["import merge from 'lodash.merge';\n\nimport { AxisOption, DataOption, LegendOption, ScatterDataType } from \"../types\";\nimport { Layer } from \"./Layer\";\nimport { Viewport } from \"./Viewport\";\nimport { drawCircle } from \"../utils/draw\";\nimport { YAxis } from \"./YAxis\";\nimport { XAxis } from \"./XAxis\";\nimport { AXIS_INNER_PADDING, AXIS_TICK_LENGTH, CONTAINER_HEIGHT, CONTAINER_WIDTH, LAYER_DEFAULT_PRIORITY, TEXT_MARGIN_BOTTOM, TEXT_MARGIN_LEFT, TEXT_MARGIN_RIGHT, TEXT_MARGIN_TOP } from \"../constants/ui\";\nimport { GridAxis } from \"./GridAxis\";\nimport { Legend } from \"./Legend\";\nimport { Guide } from \"./Guide\";\nimport { defaultAxisOption, defaultDataOption, defaultLegendOption } from \"../constants/options\";\n\nexport interface ScatterChartOption {\n  axis: { x: AxisOption, y: AxisOption };\n  data: DataOption[];\n  legend?: LegendOption;\n}\n\nexport class ScatterChart {\n  private wrapper;\n  private canvasWrapper;\n  private options!: ScatterChartOption;\n  private xAxis!: XAxis;\n  private yAxis!: YAxis;\n  private gridAxis!: GridAxis;\n  private legend!: Legend;\n  private dataColorMap!: { [key: string]: string };\n  private viewport!: Viewport;\n  private guide!: Guide;\n  private layers: { [key: string]: Layer } = {};\n  private datas: {[key: string]: number[]} = {};\n  private xRatio = 1;\n  private yRatio = 1;\n  private coordX = 0;\n  private coordY = 0;\n  private realtimeAxisMinX = 0;\n  private realtimeAxisMaxX = 0;\n  private width = 0;\n  private height = 0;\n  private padding = {\n    top: 15,\n    bottom: 20,\n    left: 0,\n    right: 0,\n  }\n  private t0: number = 0;\n  private reqAnimation = 0;\n\n  constructor(wrapper: HTMLElement, options: ScatterChartOption) {\n    this.wrapper = wrapper;\n    this.canvasWrapper = document.createElement('div');\n    this.canvasWrapper.style.position = 'relative';\n    this.wrapper.append(this.canvasWrapper);\n\n    this.setOptions(options);\n    this.setWrapperSize();\n    this.setViewPort();\n    this.setPadding();\n    this.setRatio();\n    this.setAxis();\n    this.setGuide();\n    this.setLayers();\n    this.setLegends();\n\n    this.shoot();\n    this.animate = this.animate.bind(this);\n  }\n\n  private setOptions(options: ScatterChartOption) {\n    this.options = {\n      // TODO deep copy\n      axis: merge(defaultAxisOption, options.axis),\n      data: [...defaultDataOption, ...options.data],\n      legend: merge(defaultLegendOption, options.legend),\n    };\n\n    this.dataColorMap = this.options.data.reduce((prev, curr) => {\n      return {\n        [curr.type]: curr.color,\n        ...prev,\n      }\n    }, {});\n  }\n\n  private setWrapperSize() {\n    this.width = this.wrapper.clientWidth || CONTAINER_WIDTH;\n    this.height = this.wrapper.clientHeight || CONTAINER_HEIGHT;\n  }\n\n  private setPadding() {\n    const xformatter = this.options.axis.x.tick?.format;\n    const yformatter = this.options.axis.y.tick?.format;\n    const formattedMaxX = xformatter ? xformatter(this.options.axis.x.max) : this.options.axis.x.max;\n    const formattedMaxY = yformatter ? yformatter(this.options.axis.y.max) : this.options.axis.y.max;\n    const maxXWidth = this.viewport.viewLayer.getTextWidth(formattedMaxX);\n    const maxYWidth = this.viewport.viewLayer.getTextWidth(formattedMaxY);\n\n    this.padding.left = (maxXWidth / 2 > maxYWidth ? maxXWidth / 2 : maxYWidth) + TEXT_MARGIN_LEFT + TEXT_MARGIN_RIGHT + AXIS_TICK_LENGTH;\n    this.padding.right = maxXWidth / 2 + TEXT_MARGIN_RIGHT;\n    this.padding.bottom = this.viewport.viewLayer.getTextHeight(formattedMaxX) + TEXT_MARGIN_TOP + TEXT_MARGIN_BOTTOM + AXIS_TICK_LENGTH;\n  }\n\n  private setViewPort() {\n    this.viewport = new Viewport(\n      this.canvasWrapper,\n      { width: this.width, height: this.height }\n    );\n  }\n\n  private setGuide() {\n    this.guide = new Guide(\n      this.canvasWrapper,\n      { \n        width: this.width, \n        height: this.height, \n        padding: this.padding, \n        axisOption: this.options.axis,\n        ratio: {\n          x: this.xRatio,\n          y: this.yRatio,\n        }\n      }\n    )\n  }\n\n  private setAxis() {\n    const options = this.options;\n\n    this.yAxis = new YAxis({\n      min: options.axis.y.min,\n      max: options.axis.y.max,\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: -2,\n      fixed: true,\n      tickOption: options.axis.y.tick,\n    });\n\n    this.xAxis = new XAxis({\n      min: options.axis.x.min,\n      max: options.axis.x.max,\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: -1,\n      tickOption: options.axis.x.tick,\n    });\n\n    this.gridAxis = new GridAxis({\n      min: options.axis.x.min,\n      max: options.axis.x.max,\n      width: this.width, \n      height: this.height, \n      padding: this.padding,\n      priority: 9999,\n      xTickCount: options.axis.x.tick?.count,\n      yTickCount: options.axis.y.tick?.count,\n    })\n\n    this.viewport.addLayer(this.yAxis);\n    this.viewport.addLayer(this.xAxis);\n    this.viewport.addLayer(this.gridAxis);\n  }\n\n  private setLayers() {\n    const width = this.viewport.styleWidth;\n    const height = this.viewport.styleHeight;\n    const dataOptions = this.options.data;\n\n    dataOptions.forEach(({ type, priority = LAYER_DEFAULT_PRIORITY }) => {\n      this.setLayer(type, width, height, priority);\n    })\n  }\n\n  private setLayer(legend: string, width: number, height: number, priority: number) {\n    const layer = new Layer({ width, height });\n    layer.id = legend;\n    layer.priority = priority;\n    this.layers[legend] = layer;\n    this.viewport.addLayer(layer);\n  }\n\n  private setLegends() {\n    this.legend = new Legend(this.wrapper, { \n      types: Object.keys(this.layers), \n      dataColorMap: this.dataColorMap,\n      legendOptions: this.options?.legend!\n    });\n    this.legend.addEvents(({ type, checked }) => {\n      if (type) {\n        if (checked) {\n          this.viewport.showLayer(type);\n        } else {\n          this.viewport.hideLayer(type);\n        }\n      }\n      this.shoot();\n    }).render();\n  }\n\n  private setRatio() {\n    const axis = this.options?.axis;\n    const padding = this.padding;\n    const width = this.viewport.canvas.width / this.viewport.viewLayer.dpr;\n    const height = this.viewport.canvas.height / this.viewport.viewLayer.dpr;\n    const minX = axis.x.min;\n    const maxX = axis.x.max;\n    const minY = axis.y.min;\n    const maxY = axis.y.max;\n\n    this.xRatio = (width - padding.left - padding.right - AXIS_INNER_PADDING * 2) / (maxX - minX);\n    this.yRatio = (height - padding.bottom - padding.top - AXIS_INNER_PADDING * 2) / (maxY - minY);\n  }\n\n  private shoot() {\n    this.viewport.clear();\n    this.viewport.render(this.coordX, this.coordY);\n    \n    Object.keys(this.datas).forEach(key => {\n      // this.datas[key].sort((a,b) => a - b);\n      this.legend.setLegendCount(key, this.datas[key].length);\n    })\n  }\n\n  private animate(duration: number, now: number) {\n    this.shoot();\n    if (!this.t0) this.t0 = now;\n    const dt = now - this.t0;\n    const pixcelPerFrame = (this.viewport.styleWidth - this.padding.left - this.padding.right - AXIS_INNER_PADDING * 2) / duration * dt;\n    const pixcelPerSecond = pixcelPerFrame * 60;\n\n    this.t0 = now;\n    this.coordX = this.coordX - pixcelPerFrame;\n\n    // 특정 주기마다 시행\n    if (Math.abs(Math.floor(this.coordX)) % (Math.floor(pixcelPerSecond / 5)) === 0) {\n      const x = Math.abs(this.coordX) / this.xRatio;\n      Object.keys(this.datas).forEach(key => {\n        this.datas[key] = this.datas[key].filter(d => d > x);\n      })\n\n      this.guide.updateXAxis({ min: x + this.xAxis.min});\n    }\n\n    if (this.coordX > -(this.viewport.styleWidth - this.padding.left - this.padding.right - AXIS_INNER_PADDING * 2)) {\n      this.reqAnimation = requestAnimationFrame((t) => this.animate(duration, t))\n    } else {\n      // swap\n      const nextAxisMinX = this.realtimeAxisMinX + (this.realtimeAxisMaxX - this.realtimeAxisMinX) / 2;\n      const nextAxisMaxX = this.realtimeAxisMaxX + (this.realtimeAxisMaxX - this.realtimeAxisMinX) / 2;\n      this.realtimeAxisMinX = nextAxisMinX;\n      this.realtimeAxisMaxX = nextAxisMaxX;\n      this.coordX = 0;\n\n      this.xAxis\n        .setMinMax(this.realtimeAxisMinX, this.realtimeAxisMaxX)\n        .render();\n      Object.values(this.layers).filter(layer => !layer.isFixed).forEach(layer =>  layer.swapCanvasImage());\n      this.reqAnimation = requestAnimationFrame((t) => this.animate(duration, t))\n    }\n  }\n\n  public render(data: ScatterDataType[], { append = false } = {}) {\n    this.setRatio();\n    const { styleWidth, styleHeight } = this.viewport;\n    const padding = this.padding;\n\n    !append && this.viewport.clear();\n    data.forEach(({ x, y, type, hidden }, i) => {\n      const legend = type ? type : 'unknown';\n      \n      if (!this.layers[legend]) {\n        this.setLayer(legend, styleWidth, styleHeight, LAYER_DEFAULT_PRIORITY);\n      }\n\n      if (this.datas[legend]) {\n        this.datas[legend].push(x);\n      } else {\n        this.datas[legend] = [x];\n      }\n\n      !hidden && drawCircle(\n        this.layers[legend].context,\n        this.xRatio * x + padding.left + AXIS_INNER_PADDING,\n        this.viewport.canvas.height / this.viewport.viewLayer.dpr - this.yRatio * y - padding.bottom - AXIS_INNER_PADDING,\n        {\n          fillColor: this.dataColorMap[legend],\n        }\n      );\n    });\n    this.shoot();\n  }\n\n  // public startRealtime(duration: number) {\n  //   if (this.reqAnimation) return;\n  //   const axisOptions = this.options.axis;\n  //   this.xAxis\n  //     .setTickCount(axisOptions.x.tick?.count! * 2 - 1)\n  //     .setSize(this.width * 2 - this.padding.left - AXIS_INNER_PADDING * 2 - this.padding.right, this.height)\n  //     .setMinMax(axisOptions.x.min, axisOptions.x.max * 2 - axisOptions.x.min)\n  //     .render();\n  //   this.realtimeAxisMinX = axisOptions.x.min;\n  //   this.realtimeAxisMaxX = axisOptions.x.max * 2 - axisOptions.x.min;\n\n  //   this.gridAxis\n  //     .setXTickCount(axisOptions.x.tick?.count! * 2 - 1)\n  //     .setSize(this.width * 2 - this.padding.left - AXIS_INNER_PADDING * 2 - this.padding.right, this.height)\n  //     .render();\n  //   this.animate(duration, this.t0);\n  // }\n\n  // public stopRealtime() {\n  //   cancelAnimationFrame(this.reqAnimation);\n  //   const axisOptions = this.options.axis;\n  //   this.reqAnimation = 0;\n  //   this.coordX = 0;\n  //   this.t0 = 0;\n\n  //   this.xAxis\n  //     .setTickCount(axisOptions.x.tick?.count!)\n  //     .setSize(this.width, this.height)\n  //     .setMinMax(axisOptions.x.min, axisOptions.x.max)\n  //     .render();\n  //   this.realtimeAxisMinX = axisOptions.x.min;\n  //   this.realtimeAxisMaxX = axisOptions.x.max;\n\n  //   this.guide.updateXAxis({ min: axisOptions.x.min });\n\n  //   this.gridAxis\n  //     .setXTickCount(axisOptions.x.tick?.count!)\n  //     .setSize(this.width, this.height)\n  //     .render();\n  //   this.shoot();\n  // }\n\n  public on(evetntType: string, callback: (data: any) => void) {\n    this.guide.on(evetntType, callback);\n  }\n\n  // swapPaperCanvasImage(ctx: CanvasRenderingContext2D) {\n  //   // const leftImage = this.getCroppedImage(ctx, { x: 0, y: 0 }, { x: 400, y: 400 });\n  //   const rightImage = this.getCroppedImage(ctx, { x: 400, y: 0 }, { x: 800, y: 400 });\n  //   ctx.clearRect(0, 0, this.viewport.styleWidth, this.viewport.styleHeight);\n  //   ctx.putImageData(rightImage, 0, 0)\n  // }\n\n  // getCroppedImage(ctx: CanvasRenderingContext2D, lCoord: Coord, rCoord: Coord) {\n  //   return ctx.getImageData(lCoord.x, lCoord.y, rCoord.x, rCoord.y);\n  // }\n}\n"],"names":[],"sourceRoot":""}